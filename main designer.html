<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Goods Elevator Designer</title>
    
    <!-- Added door model scripts -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Dils98/Designer@main/main-designer.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Dils98/Designer@main/grid-controls.css">
    <script src="https://cdn.jsdelivr.net/gh/Dils98/Designer@main/collapsible-door.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/Dils98/Designer@main/roller-gate.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/Dils98/Designer@main/swing-door.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/Dils98/Designer@main/grid-modeling.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/Dils98/Designer@main/horizontal-beams.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/Dils98/Designer@main/elevator-video-export.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/Dils98/Designer@main/main%20designer.js"></script>
    <!-- Three.js and related libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/exporters/OBJExporter.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            background-color: #f5f5f5;
        }
        #container {
            display: flex;
            height: 100vh;
        }
        #designer-panel {
            width: 350px;
            background: #fff;
            border-right: 1px solid #ddd;
            padding: 15px;
            overflow-y: auto;
        }
        #viewport {
            flex: 1;
            position: relative;
        }
        #canvas {
            width: 100%;
            height: 100%;
            background-color: #f9f9f9;
        }
        .control-group {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }
        .control-group h3 {
            margin-top: 0;
            color: #333;
            font-size: 16px;
        }
        label {
            display: block;
            margin: 8px 0 4px;
            font-size: 13px;
            color: #555;
        }
        input[type="range"], select, input[type="number"] {
            width: 100%;
            margin-bottom: 10px;
        }
        .value-display {
            font-size: 12px;
            color: #777;
            text-align: right;
        }
        button {
            background: #2c7be5;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            margin-right: 5px;
            margin-bottom: 5px;
        }
        button:hover {
            background: #1a68d4;
        }
        .measurement-line {
            position: absolute;
            background-color: rgba(231, 76, 60, 0.7);
            pointer-events: none;
            z-index: 100;
        }
        .measurement-text {
            position: absolute;
            background-color: white;
            padding: 2px 5px;
            border-radius: 3px;
            font-size: 12px;
            pointer-events: none;
            border: 1px solid #ddd;
            z-index: 101;
            color: #333;
            font-weight: bold;
        }
        .measurement-arrow {
            position: absolute;
            width: 0;
            height: 0;
            border-style: solid;
            pointer-events: none;
            z-index: 100;
        }
        .tool-button {
            display: inline-block;
            padding: 5px 10px;
            background: #e9ecef;
            border-radius: 3px;
            margin-right: 5px;
            margin-bottom: 5px;
            cursor: pointer;
            font-size: 12px;
        }
        .tool-button.active {
            background: #2c7be5;
            color: white;
        }
        .animation-controls {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #eee;
        }
        .scale-control {
            display: flex;
            align-items: center;
            margin-top: 5px;
        }
        .scale-control input {
            flex: 1;
            margin-right: 10px;
        }
        .door-preview {
            margin-top: 10px;
            padding: 10px;
            background: #f0f0f0;
            border-radius: 4px;
        }
        .floor-controls {
            margin-top: 10px;
        }
        .floor-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 5px;
            background: #f8f9fa;
            margin-bottom: 5px;
            border-radius: 3px;
        }
        .floor-config {
            margin-top: 5px;
            padding: 5px;
            background: #f0f8ff;
            border-radius: 3px;
        }
        .floor-door-config {
            margin-top: 5px;
            padding: 5px;
            background: #fff8f0;
            border-radius: 3px;
        }
        .door-position-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            margin-top: 5px;
        }
        .door-position-controls input {
            width: 100%;
        }
        .floor-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 10px;
            border: 1px solid #eee;
            padding: 5px;
            border-radius: 4px;
        }
        .door-sides-control {
            margin-top: 10px;
        }
        .door-side-option {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }
        .door-side-option input {
            width: auto;
            margin-right: 8px;
        }
        .color-picker {
            width: 30px;
            height: 30px;
            padding: 0;
            border: 1px solid #ccc;
            vertical-align: middle;
        }
        .opacity-slider {
            width: 60px;
            display: inline-block;
            margin-left: 10px;
        }
        .column-rotation-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 5px;
            margin-top: 5px;
        }
        .column-rotation-controls input {
            width: 100%;
        }
        .measurement-detail {
            position: absolute;
            background-color: white;
            padding: 5px;
            border-radius: 4px;
            font-size: 11px;
            pointer-events: none;
            border: 1px solid #ddd;
            z-index: 102;
            color: #333;
            max-width: 200px;
            text-align: center;
        }
        .unified-rotation-control {
            margin-top: 10px;
        }
        .a-frame-options {
            display: flex;
            margin-top: 10px;
            margin-bottom: 10px;
        }
        .a-frame-option {
            flex: 1;
            text-align: center;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
        }
        .a-frame-option:last-child {
            margin-right: 0;
        }
        .a-frame-option.selected {
            border-color: #2c7be5;
            background-color: #e6f0fd;
        }
        .beam-config {
            margin-top: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
        }
        .beam-options {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-top: 5px;
        }
        .beam-option {
            display: flex;
            align-items: center;
        }
        .beam-option input[type="checkbox"] {
            margin-right: 8px;
            width: auto;
        }
        .grid-controls {
            margin-top: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 4px;
        }
        .grid-type-options {
            display: flex;
            margin-top: 10px;
            margin-bottom: 10px;
        }
        .grid-type-option {
            flex: 1;
            text-align: center;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 5px;
        }
        .grid-type-option:last-child {
            margin-right: 0;
        }
        .grid-type-option.selected {
            border-color: #2c7be5;
            background-color: #e6f0fd;
        }
        .grid-side-options {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 5px;
            margin-top: 10px;
        }
        .grid-side-option {
            text-align: center;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
        }
        .grid-side-option.selected {
            border-color: #2c7be5;
            background-color: #e6f0fd;
        }
        .grid-beam-controls {
            margin-top: 10px;
            padding: 10px;
            background: #f0f8ff;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="designer-panel">
            <h2>Advanced Goods Elevator Designer</h2>
            
            <div class="control-group">
                <h3>Dimensions (mm)</h3>
                <label for="elevatorWidth">Cabin Width:</label>
                <input type="range" id="elevatorWidth" min="1000" max="5000" step="50" value="2000">
                <div class="value-display"><span id="widthValue">2000</span> mm</div>
                
                <label for="elevatorDepth">Cabin Depth:</label>
                <input type="range" id="elevatorDepth" min="1000" max="4000" step="50" value="1500">
                <div class="value-display"><span id="depthValue">1500</span> mm</div>
                
                <label for="elevatorHeight">Cabin Height:</label>
                <input type="range" id="elevatorHeight" min="1000" max="3000" step="50" value="2000">
                <div class="value-display"><span id="heightValue">2000</span> mm</div>
                
                <label for="shaftHeight">Shaft Height:</label>
                <input type="range" id="shaftHeight" min="3000" max="55000" step="100" value="10000">
                <div class="value-display"><span id="shaftHeightValue">10000</span> mm</div>
            </div>
            
            <div class="control-group">
                <h3>Structural Elements</h3>
                <label for="columnType">Column Type:</label>
                <select id="columnType">
                    <option value="none">No Columns</option>
                    <option value="hbeam100">H-Beam 100×100×6×8</option>
                    <option value="hbeam200" selected>H-Beam 200×200×8×12</option>
                    <option value="hbeam300">H-Beam 300×300×10×15</option>
                    <option value="rectTube100x50">Rect Tube 100×50×6.35</option>
                    <option value="rectTube150x75">Rect Tube 150×75×6.35</option>
                    <option value="cChannel80">C-Channel 80×40×6×8</option>
                    <option value="cChannel100">C-Channel 100×50×6×10</option>
                    <option value="cChannel150">C-Channel 150×75×6×12</option>
                    <option value="lAngle50x50">L-Angle 50×50×5</option>
                    <option value="lAngle75x75">L-Angle 75×75×6</option>
                    <option value="lAngle100x100">L-Angle 100×100×8</option>
                    <option value="central">Central Columns (2)</option>
                </select>
                
                <label for="columnCount">Column Count:</label>
                <select id="columnCount">
                    <option value="4" selected>4 Columns (Corners)</option>
                    <option value="2">2 Columns (Front/Back)</option>
                </select>
                
                <label for="columnOffset">Column Offset from Cabin:</label>
                <input type="range" id="columnOffset" min="0" max="500" step="10" value="50">
                <div class="value-display"><span id="columnOffsetValue">50</span> mm</div>
                
                <label for="columnXPosition">Column X Position (Left/Right):</label>
                <input type="range" id="columnXPosition" min="0" max="500" step="10" value="0" oninput="updateColumnX(this.value)">
                <div class="value-display"><span id="columnXPositionValue">0</span> mm</div>
                
                <label for="columnZPosition">Column Z Position (Front/Back):</label>
                <input type="range" id="columnZPosition" min="0" max="500" step="10" value="0" oninput="updateColumnZ(this.value)">
                <div class="value-display"><span id="columnZPositionValue">0</span> mm</div>
                
                <button id="forceColumnUpdate" onclick="forceUpdateColumns()">Force Update Columns</button>
                
                <label for="cageOffset">Cage Offset:</label>
                <input type="range" id="cageOffset" min="0" max="500" step="10" value="100">
                <div class="value-display"><span id="cageOffsetValue">100</span> mm</div>
                
                <div class="beam-option" style="margin-top: 10px;">
                    <input type="checkbox" id="enableCage">
                    <label for="enableCage">Enable Cage Structure</label>
                </div>
                
                <div class="unified-rotation-control">
                    <label for="unifiedColumnRotation">Unified Column Rotation:</label>
                    <input type="range" id="unifiedColumnRotation" min="-180" max="180" step="1" value="0">
                    <div class="value-display"><span id="unifiedColumnRotationValue">0</span>°</div>
                </div>
                
                <div id="columnRotationControls" class="column-rotation-controls">
                    <!-- Column rotation controls will be added here dynamically -->
                </div>
                
                <!-- Horizontal Beam Configuration -->
                <div class="beam-config">
                    <label>Horizontal Beam Sections:</label>
                    <input type="range" id="horizontalBeamSections" min="0" max="20" step="1" value="0">
                    <div class="value-display"><span id="horizontalBeamSectionsValue">0</span> sections</div>
                    <div class="value-display">Section Height: <span id="sectionHeightValue">0</span> mm</div>
                    <div class="value-display">Diagonal Length: <span id="diagonalLengthValue">0</span> mm</div>
                    <div class="value-display">Corner to Corner: <span id="cornerDistanceValue">0</span> mm</div>
                    
                    <label>Horizontal Beam Type:</label>
                    <select id="horizontalBeamType">
                        <option value="rectTube50x30">Rect Tube 50×30×3.175</option>
                        <option value="rectTube80x40" selected>Rect Tube 80×40×3.175</option>
                        <option value="rectTube100x50">Rect Tube 100×50×6.35</option>
                    </select>
                    
                    <div class="beam-options">
                        <div class="beam-option">
                            <input type="checkbox" id="enableDiagonalSupports" checked>
                            <label for="enableDiagonalSupports">Diagonal Supports</label>
                        </div>
                    </div>
                </div>
                
                <!-- Motor Hanging Structure Configuration -->
                <div class="motor-config">
                    <h3>Motor Hanging Structure</h3>
                    <label for="motorConfig">Configuration:</label>
                    <select id="motorConfig">
                        <option value="none" selected>None</option>
                        <option value="leftRight">Left/Right</option>
                        <option value="frontBack">Front/Back</option>
                    </select>
                    
                    <label for="motorOffset">Vertical Offset from Top:</label>
                    <input type="range" id="motorOffset" min="0" max="1000" step="10" value="0">
                    <div class="value-display"><span id="motorOffsetValue">0</span> mm</div>
                    
                    <div class="beam-option" style="margin-top:10px;">
                        <input type="checkbox" id="enableVerticalSupport">
                        <label for="enableVerticalSupport">Add Vertical Support</label>
                    </div>
                    
                    <!-- Add the beam rotation control -->
                    <label for="topBeamRotation">Top Beam Rotation:</label>
                    <input type="range" id="topBeamRotation" min="0" max="360" step="1" value="0">
                    <div class="value-display"><span id="topBeamRotationValue">0</span>°</div>
                </div>
            </div>
            
            <div class="control-group" id="frameConfigGroup">
                <h3>Cabin Frame Structure</h3>
                <label for="frameType">Frame Configuration:</label>
                <select id="frameType">
                    <option value="standard">Standard Rectangular Frame</option>
                    <option value="aFrame">A-Frame Structure</option>
                </select>
                
                <div id="aFrameOptions" style="display: none;">
                    <label>A-Frame Placement:</label>
                    <div class="a-frame-options">
                        <div class="a-frame-option selected" data-sides="leftRight">Left & Right</div>
                        <div class="a-frame-option" data-sides="frontBack">Front & Back</div>
                    </div>
                    
                    <div class="grid-controls">
                        <label>A-Frame Grid Divisions:</label>
                        <input type="number" id="aFrameGridDivisions" min="1" max="10" value="4">
                    </div>
                </div>
                
                <div class="frame-preview" id="framePreview">
                    Standard Rectangular Frame with vertical posts at each corner and horizontal beams
                </div>
                
                <label for="materialType">Material Profile:</label>
                <select id="materialType">
                    <option value="rectTube">Rectangular Tube</option>
                    <option value="cChannel">C-Channel</option>
                    <option value="lAngle">L-Angle</option>
                    <option value="hBeam">H-Beam</option>
                </select>
                
                <label for="materialSize">Material Size:</label>
                <select id="materialSize">
                    <option value="small">Small (50x50mm)</option>
                    <option value="medium">Medium (80x80mm)</option>
                    <option value="large">Large (100x100mm)</option>
                </select>
                
                <div class="grid-controls">
                    <label>Grid Configuration:</label>
                    <div style="display: flex; justify-content: space-between;">
                        <div style="width: 48%;">
                            <label for="horizontalGridDivisions">Horizontal Divisions:</label>
                            <input type="number" id="horizontalGridDivisions" min="0" max="8" value="2">
                        </div>
                        <div style="width: 48%;">
                            <label for="verticalGridDivisions">Vertical Divisions:</label>
                            <input type="number" id="verticalGridDivisions" min="0" max="8" value="2">
                        </div>
                    </div>
                </div>
                
                <div class="beam-config">
                    <label>Beam Configuration:</label>
                    <div class="beam-options">
                        <div class="beam-option">
                            <input type="checkbox" id="enableDiagonalSupports" checked>
                            <label for="enableDiagonalSupports">Diagonal Supports</label>
                        </div>
                        <div class="beam-option">
                            <input type="checkbox" id="enableMiddleBeams" checked>
                            <label for="enableMiddleBeams">Middle Beams</label>
                        </div>
                        <div class="beam-option">
                            <input type="checkbox" id="enableCrossBeams" checked>
                            <label for="enableCrossBeams">Cross Beams</label>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Add Grid Modeling Controls -->
            <div class="control-group">
                <h3>Grid Modeling</h3>
                <div class="grid-controls">
                    <label>Grid Type</label>
                    <div class="grid-type-options">
                        <div class="grid-type-option selected" data-type="none">None</div>
                        <div class="grid-type-option" data-type="vertical">Vertical</div>
                        <div class="grid-type-option" data-type="horizontal">Horizontal</div>
                        <div class="grid-type-option" data-type="crossed">Crossed</div>
                    </div>

                    <label>Grid Divisions</label>
                    <input type="number" id="grid-divisions" min="1" max="20" value="5">

                    <label>Side Selection</label>
                    <div class="grid-side-options">
                        <div class="grid-side-option selected" data-side="front">Front</div>
                        <div class="grid-side-option" data-side="back">Back</div>
                        <div class="grid-side-option" data-side="left">Left</div>
                        <div class="grid-side-option" data-side="right">Right</div>
                        <div class="grid-side-option" data-side="top">Top</div>
                        <div class="grid-side-option" data-side="bottom">Bottom</div>
                    </div>

                    <div class="grid-beam-controls">
                        <label>Grid Material Type</label>
                        <select id="grid-material-type">
                            <option value="rectTube">Rectangular Tube</option>
                        </select>

                        <label>Grid Material Size</label>
                        <select id="grid-material-size">
                            <option value="50×25×3.2mm">50×25×3.2mm</option>
                            <option value="75×50×3.2mm">75×50×3.2mm</option>
                            <option value="100×50×4mm">100×50×4mm</option>
                            <option value="120×60×4mm">120×60×4mm</option>
                            <option value="150×75×5mm">150×75×5mm</option>
                            <option value="200×100×6mm">200×100×6mm</option>
                        </select>
                    </div>

                    <div style="margin-top: 10px;">
                        <button id="apply-grid">Apply Grid</button>
                        <button id="clear-grid">Clear Grid</button>
                    </div>
                </div>
            </div>
            
            <div class="control-group">
                <h3>Cabin Door Configuration</h3>
                <label for="doorType">Door Type:</label>
                <select id="doorType">
                    <option value="none">No Door</option>
                    <option value="bifold">Bifold Door</option>
                    <option value="collapsible">Collapsible Door</option>
                    <option value="roller">Roller Gate</option>
                    <option value="swingSingle">Swing Door (Single)</option>
                    <option value="swingDouble">Swing Door (Double)</option>
                </select>
                
                <label for="doorWidth">Door Width:</label>
                <input type="range" id="doorWidth" min="500" max="2000" step="50" value="1000">
                <div class="value-display"><span id="doorWidthValue">1000</span> mm</div>
                
                <label for="doorPanelCount">Panel Count (for bifold):</label>
                <select id="doorPanelCount">
                    <option value="2">2 Panels</option>
                    <option value="4" selected>4 Panels</option>
                    <option value="6">6 Panels</option>
                </select>
                
                <div class="door-sides-control">
                    <label>Door Sides:</label>
                    <div class="door-side-option">
                        <input type="checkbox" id="cabinDoorFront" checked>
                        <label for="cabinDoorFront">Front</label>
                    </div>
                    <div class="door-side-option">
                        <input type="checkbox" id="cabinDoorBack">
                        <label for="cabinDoorBack">Back</label>
                    </div>
                    <div class="door-side-option">
                        <input type="checkbox" id="cabinDoorLeft">
                        <label for="cabinDoorLeft">Left Side</label>
                    </div>
                    <div class="door-side-option">
                        <input type="checkbox" id="cabinDoorRight">
                        <label for="cabinDoorRight">Right Side</label>
                    </div>
                </div>
                
                <div class="door-position-controls">
                    <div>
                        <label for="leftDoorOffset">Left Side Offset (mm):</label>
                        <input type="number" id="leftDoorOffset" min="-1000" max="1000" step="10" value="0">
                    </div>
                    <div>
                        <label for="rightDoorOffset">Right Side Offset (mm):</label>
                        <input type="number" id="rightDoorOffset" min="-1000" max="1000" step="10" value="0">
                    </div>
                </div>
                
                <div>
                    <label>Door Color:</label>
                    <input type="color" id="cabinDoorColor" value="#CCCCCC" class="color-picker">
                    <label>Opacity:</label>
                    <input type="range" id="cabinDoorOpacity" min="0" max="100" value="100" class="opacity-slider">
                    <span id="cabinDoorOpacityValue">100%</span>
                </div>
                
                <div class="door-preview" id="doorPreview">
                    Door Preview: Bifold Door (Front) - 4 Panels
                </div>
                
                <button id="toggleDoorBtn">Open/Close Door</button>
            </div>
            
            <div class="control-group">
                <h3>Floor Management</h3>
                <div>
                    <label for="baseFloorHeight">Base Floor Height (mm):</label>
                    <input type="number" id="baseFloorHeight" min="2000" max="5000" step="100" value="3000">
                </div>
                <div>
                    <label for="floorCount">Number of Floors:</label>
                    <input type="number" id="floorCount" min="2" max="20" step="1" value="3">
                </div>
                <button id="generateFloorsBtn">Generate Floors</button>
                
                <div class="floor-list" id="floorList">
                    <!-- Floors will be listed here -->
                </div>
                
                <div id="floorConfigPanel" style="display: none;">
                    <h4>Floor Configuration</h4>
                    <div id="floorConfigDetails"></div>
                </div>
            </div>
            
            <div class="control-group">
                <h3>Transparency Controls</h3>
                
                <label for="floorTransparency">Floor Transparency:</label>
                <input type="range" id="floorTransparency" min="0" max="100" value="30">
                <div class="value-display"><span id="floorTransparencyValue">30</span>%</div>
                
                <label for="indicatorTransparency">Top Indicator Transparency:</label>
                <input type="range" id="indicatorTransparency" min="0" max="100" value="70">
                <div class="value-display"><span id="indicatorTransparencyValue">70</span>%</div>
            </div>
            
            <div class="control-group">
                <h3>View & Measurement</h3>
                <div>
                    <span class="tool-button active" id="topView">Top View</span>
                    <span class="tool-button" id="frontView">Front View</span>
                    <span class="tool-button" id="sideView">Side View</span>
                    <span class="tool-button" id="isoView">3D View</span>
                </div>

                
                <label style="margin-top: 10px;">Measurement Scale:</label>
                <div class="scale-control">
                    <input type="range" id="measurementScale" min="8" max="24" step="1" value="12">
                    <span id="measurementScaleValue">12</span>px
                </div>
                
                <div style="margin-top: 10px;">
                    <span class="tool-button active" id="toggleMeasure">Measurements: On</span>
                </div>
            </div>
            
            <div class="control-group animation-controls">
                <h3>Elevator Operation</h3>
                <button id="animateBtn">Start Operation</button>
                <button id="stopBtn" style="display: none;">Stop Operation</button>
                <div style="margin-top: 10px;">
                    <label for="animationSpeed">Speed:</label>
                    <input type="range" id="animationSpeed" min="1" max="10" value="5">
                </div>
                <div style="margin-top: 10px;">
                    <input type="checkbox" id="requireFloorDoor" checked>
                    <label for="requireFloorDoor">Cabin door opens only when floor door present</label>
                </div>
                <div class="value-display">Current Floor: <span id="currentFloor">0</span></div>
                <div class="value-display">Position: <span id="positionValue">0</span> mm</div>
                
                <div style="margin-top: 10px;">
                    <h4>Floor Selection</h4>
                    <div id="floorSelectionList"></div>
                </div>
            </div>
            <div style="margin-top: 10px;">
    <label>Floor Visibility:</label>
    <div>
        <span class="tool-button active" id="floorsAllViews">All Views</span>
        <span class="tool-button" id="floorsNoTopView">Hide in Top View</span>
        <span class="tool-button" id="floorsNoViews">Hide in All Views</span>
    </div>
</div>
            <div class="control-group">
                <h3>Actions</h3>
                <button id="exportBtn">Export Drawing</button>
                <button id="printBtn">Print Design</button>
                <button id="saveBtn">Save Project</button>
                <button id="loadBtn">Load Project</button>
                <button id="resetBtn">Reset View</button>
            </div>

            <!-- Add BOQ and BOM Section -->
            <div class="control-group">
                <h3>Bill of Quantities & Materials</h3>
                <button id="generateBOQ" onclick="generateBOQAndBOM()">Generate BOQ & BOM</button>
                <div id="boqOutput" class="boq-output"></div>
            </div>
        </div>

        <style>
            /* Add styles for BOQ output */
            .boq-output {
                margin-top: 15px;
                padding: 10px;
                background: #f8f9fa;
                border-radius: 4px;
                font-size: 13px;
                max-height: 300px;
                overflow-y: auto;
            }
            .boq-output table {
                width: 100%;
                border-collapse: collapse;
                margin-top: 10px;
            }
            .boq-output th, .boq-output td {
                border: 1px solid #ddd;
                padding: 8px;
                text-align: left;
            }
            .boq-output th {
                background-color: #f0f0f0;
            }
            .boq-output tr:nth-child(even) {
                background-color: #f9f9f9;
            }
            .boq-section {
                margin-bottom: 15px;
            }
            .boq-section h4 {
                margin: 10px 0 5px 0;
                color: #2c7be5;
            }
        </style>

        <script>
            function generateBOQAndBOM() {
                const boqOutput = document.getElementById('boqOutput');
                
                // Get current dimensions and settings
                const width = parseFloat(document.getElementById('elevatorWidth').value);
                const depth = parseFloat(document.getElementById('elevatorDepth').value);
                const height = parseFloat(document.getElementById('elevatorHeight').value);
                const shaftHeight = parseFloat(document.getElementById('shaftHeight').value);
                const columnType = document.getElementById('columnType').value;
                const columnCount = parseInt(document.getElementById('columnCount').value);
                const enableCage = document.getElementById('enableCage').checked;

                // Calculate quantities
                const calculations = calculateQuantities(width, depth, height, shaftHeight, columnType, columnCount, enableCage);
                
                // Generate HTML output
                let html = `
                    <div class="boq-section">
                        <h4>Bill of Quantities (BOQ)</h4>
                        <table>
                            <tr>
                                <th>Item</th>
                                <th>Quantity</th>
                                <th>Unit</th>
                            </tr>
                            ${Object.entries(calculations.boq).map(([item, data]) => `
                                <tr>
                                    <td>${item}</td>
                                    <td>${data.quantity.toFixed(2)}</td>
                                    <td>${data.unit}</td>
                                </tr>
                            `).join('')}
                        </table>
                    </div>
                    <div class="boq-section">
                        <h4>Bill of Materials (BOM)</h4>
                        <table>
                            <tr>
                                <th>Material</th>
                                <th>Specification</th>
                                <th>Quantity</th>
                                <th>Unit</th>
                            </tr>
                            ${Object.entries(calculations.bom).map(([material, data]) => `
                                <tr>
                                    <td>${material}</td>
                                    <td>${data.spec}</td>
                                    <td>${data.quantity.toFixed(2)}</td>
                                    <td>${data.unit}</td>
                                </tr>
                            `).join('')}
                        </table>
                    </div>
                `;
                
                boqOutput.innerHTML = html;
            }

            function calculateQuantities(width, depth, height, shaftHeight, columnType, columnCount, enableCage) {
                const boq = {};
                const bom = {};
                
                // Calculate column lengths
                const columnLength = shaftHeight;
                const columnQuantity = columnCount;
                
                // Add columns to BOQ and BOM
                if (columnType !== 'none') {
                    const columnSpecs = getColumnSpecifications(columnType);
                    boq['Columns'] = {
                        quantity: columnLength * columnQuantity / 1000, // Convert to meters
                        unit: 'm'
                    };
                    bom[columnSpecs.name] = {
                        spec: columnSpecs.dimensions,
                        quantity: columnLength * columnQuantity / 1000,
                        unit: 'm'
                    };
                }

                // Calculate cage structure if enabled
                if (enableCage) {
                    const cageHeight = shaftHeight;
                    const cagePerimeter = 2 * (width + depth);
                    const verticalMembers = Math.ceil(cagePerimeter / 1000) * 2; // One every meter, minimum 2 per side
                    
                    boq['Cage Vertical Members'] = {
                        quantity: (cageHeight * verticalMembers) / 1000,
                        unit: 'm'
                    };
                    boq['Cage Horizontal Members'] = {
                        quantity: (cagePerimeter * Math.ceil(cageHeight / 1000)) / 1000,
                        unit: 'm'
                    };
                    
                    // Add cage materials to BOM
                    bom['Angle Iron'] = {
                        spec: '50x50x5mm',
                        quantity: ((cageHeight * verticalMembers) + (cagePerimeter * Math.ceil(cageHeight / 1000))) / 1000,
                        unit: 'm'
                    };
                    bom['Expanded Metal Mesh'] = {
                        spec: '2mm thick',
                        quantity: (cagePerimeter * cageHeight) / 1000000, // Convert to square meters
                        unit: 'm²'
                    };
                }

                // Add basic cabin structure
                boq['Cabin Floor Area'] = {
                    quantity: (width * depth) / 1000000,
                    unit: 'm²'
                };
                boq['Cabin Wall Area'] = {
                    quantity: (2 * (width + depth) * height) / 1000000,
                    unit: 'm²'
                };

                // Add floor materials to BOM
                bom['Checkered Plate'] = {
                    spec: '5mm thick',
                    quantity: (width * depth) / 1000000,
                    unit: 'm²'
                };
                bom['Wall Panels'] = {
                    spec: 'Galvanized Steel 2mm',
                    quantity: (2 * (width + depth) * height) / 1000000,
                    unit: 'm²'
                };

                return { boq, bom };
            }

            function getColumnSpecifications(columnType) {
                const specifications = {
                    'hbeam100': { name: 'H-Beam', dimensions: '100×100×6×8' },
                    'hbeam200': { name: 'H-Beam', dimensions: '200×200×8×12' },
                    'hbeam300': { name: 'H-Beam', dimensions: '300×300×10×15' },
                    'rectTube100x50': { name: 'Rectangular Tube', dimensions: '100×50×6.35' },
                    'rectTube150x75': { name: 'Rectangular Tube', dimensions: '150×75×6.35' },
                    'cChannel80': { name: 'C-Channel', dimensions: '80×40×6×8' },
                    'cChannel100': { name: 'C-Channel', dimensions: '100×50×6×10' },
                    'cChannel150': { name: 'C-Channel', dimensions: '150×75×6×12' },
                    'lAngle50x50': { name: 'L-Angle', dimensions: '50×50×5' },
                    'lAngle75x75': { name: 'L-Angle', dimensions: '75×75×6' },
                    'lAngle100x100': { name: 'L-Angle', dimensions: '100×100×8' },
                    'central': { name: 'Central Column', dimensions: '200×200×8×12' }
                };
                return specifications[columnType] || { name: 'Custom', dimensions: 'Custom' };
            }
        </script>
        
        <div id="viewport">
            <canvas id="canvas"></canvas>
            <div id="measurements-container"></div>
        </div>
    </div>

    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let elevatorGroup, elevatorPlatform, elevatorCabin, elevatorDoors = [], cabinFrame;
        let columns = [];
        let floors = [];
        let floorDoors = [];
        let cageDoorFrames = []; // Array to track cage door frames
        let floorConfigurations = [];
        let columnGroup, aFrameGroup;
        let gridPoints = [];
        let measurementLines = [];
        let doorAnimators = [];
        let elevatorPosition = 0;
        let currentOpenDoor = null;
        let doorAnimationProgress = 0;
        let doorAnimationDirection = 1;
        let doorIsAnimating = false;
        let currentView = 'top';
        let showMeasurements = true;
        let isOperating = false;
        let operationId = null;
        let currentFloorIndex = 0;
        let operationState = 'moving';
        let operationProgress = 0;
        let measurementFontSize = 12;
        let isCabinDoorOpen = false;
        // Horizontal beams variables
        let horizontalBeams = [];
        let diagonalSupports = [];
        let beamCorners = [];
        let cornerDistances = {};
        let columnRotations = [0, 0, 0, 0]; // Store rotation angles for each column
        let isFloorDoorOpen = false;
        let doorAnimationId = null;
        let floorDoorAnimationId = null;
        let topLevelIndicator = null;
        let cabinDoorColor = 0xCCCCCC;
        let cabinDoorOpacity = 1;
        let activeCabinDoors = []; // Track which cabin doors should open at current floor
        let projectData = {}; // Store project data for saving/loading
        let floorVisibilityMode = 'all'; // 'all', 'noTop', 'none'
        let floorSelection = []; // Array to store which floors are selected
        
        // Motor hanging structure variables
        let motorGroup = new THREE.Group();
        let topBeam = null;
        
        // Don't redeclare grid variables here since they're defined in grid-modeling.js
        
        function getFloorVisibilityLabel() {
            switch(floorVisibilityMode) {
                case 'all': return 'Visible in All Views';
                case 'noTop': return 'Hidden in Top View';
                case 'none': return 'Hidden in All Views';
                default: return 'Unknown Visibility';
            }
        }
        // ===== NEW EXPORT FUNCTIONS START HERE =====
        function exportAsOBJ() {
            try {
                const exporter = new THREE.OBJExporter();
                const result = exporter.parse(scene);
                
                // Create download link
                const blob = new Blob([result], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'elevator_model.obj';
                a.click();
                URL.revokeObjectURL(url);
                
                alert('OBJ export completed successfully!');
            } catch (error) {
                console.error('OBJ export error:', error);
                alert('Error exporting OBJ: ' + error.message);
            }
        }
        
        // New function to export side elevations as high-quality PNGs
        async function exportSideElevationPNGs() {
            try {
                // Store current settings
                const originalView = currentView;
                const originalMeasurements = showMeasurements;
                const originalFloorVisibility = floorVisibilityMode;
                
                // Keep measurements visible for better detail
                showMeasurements = true;
                updateMeasurements();
                
                // Array of side views to capture
                const views = [
                    { name: 'Front_Elevation', type: 'front' },
                    { name: 'Side_Elevation', type: 'side' },
                    { name: 'Top_View', type: 'top' },
                    { name: '3D_View', type: 'iso' }
                ];

                // Create a temporary container for rendering
                const tempContainer = document.createElement('div');
                tempContainer.style.position = 'absolute';
                tempContainer.style.left = '-9999px';
                document.body.appendChild(tempContainer);

                // Create a high-resolution temporary renderer with transparent background
                const tempRenderer = new THREE.WebGLRenderer({
                    antialias: true,
                    preserveDrawingBuffer: true,
                    alpha: true
                });
                
                // Higher resolution for better quality exports
                const scale = 3; // Scale factor for higher resolution
                tempRenderer.setPixelRatio(window.devicePixelRatio * scale);
                tempRenderer.setClearAlpha(0);
                tempRenderer.setSize(1920, 1080); // Full HD resolution
                tempContainer.appendChild(tempRenderer.domElement);

                // Set transparent background for the scene
                scene.background = null;

                // Store original floor visibility
                const originalFloorVisibilityStates = floors.map(floor => floor.visible);
                const originalTopIndicatorVisibility = topLevelIndicator ? topLevelIndicator.visible : true;

                // Capture each view
                for (const view of views) {
                    currentView = view.type;
                    updateView();
                    
                    // Apply floor visibility based on the selected mode
                    let showFloors = true;
                    if (originalFloorVisibility === 'noTop') {
                        showFloors = (view.type !== 'top');
                    } else if (originalFloorVisibility === 'none') {
                        showFloors = false;
                    }
                    
                    floors.forEach(floor => {
                        floor.visible = showFloors;
                    });

                    // Always show top level indicator in exports
                    if (topLevelIndicator) {
                        topLevelIndicator.visible = true;
                    }

                    // Render to our temporary renderer
                    tempRenderer.render(scene, camera);
                    
                    // Wait to ensure rendering is complete
                    await new Promise(resolve => {
                        setTimeout(() => {
                            // Create high-quality PNG
                            const imgData = tempRenderer.domElement.toDataURL('image/png', 1.0);
                            
                            // Create download link
                            const link = document.createElement('a');
                            link.href = imgData;
                            link.download = `elevator_${view.name}.png`;
                            document.body.appendChild(link);
                            link.click();
                            document.body.removeChild(link);
                            
                            resolve();
                        }, 100);
                    });
                }

                // Restore original floor visibility
                floors.forEach((floor, index) => {
                    floor.visible = originalFloorVisibilityStates[index];
                });
                if (topLevelIndicator) {
                    topLevelIndicator.visible = originalTopIndicatorVisibility;
                }

                // Clean up temporary elements
                document.body.removeChild(tempContainer);
                
                // Restore original settings
                scene.background = new THREE.Color(0xf9f9f9);
                currentView = originalView;
                showMeasurements = originalMeasurements;
                floorVisibilityMode = originalFloorVisibility;
                updateView();
                updateMeasurements();
                
                alert('Side elevation PNG exports completed successfully!');
            } catch (error) {
                console.error('PNG export error:', error);
                alert('Error exporting PNGs: ' + error.message);
                
                // Ensure cleanup even if error occurs
                if (tempContainer && tempContainer.parentNode) {
                    document.body.removeChild(tempContainer);
                }
                
                // Restore original settings
                scene.background = new THREE.Color(0xf9f9f9);
                currentView = originalView;
                showMeasurements = originalMeasurements;
                floorVisibilityMode = originalFloorVisibility;
                updateView();
                updateMeasurements();
            }
        }
        
        // Function to add a video recorder for the elevator operation with quality and format options
        async function exportOperationVideo() {
            try {
                // First check if MediaRecorder is available
                if (!window.MediaRecorder) {
                    alert('Your browser does not support video recording. Please try using Chrome or Firefox.');
                    return;
                }
                
                // Create a modal with recording controls
                const modal = document.createElement('div');
                modal.style.position = 'fixed';
                modal.style.top = '0';
                modal.style.left = '0';
                modal.style.width = '100%';
                modal.style.height = '100%';
                modal.style.backgroundColor = 'rgba(0,0,0,0.7)';
                modal.style.zIndex = '9999';
                modal.style.display = 'flex';
                modal.style.flexDirection = 'column';
                modal.style.justifyContent = 'center';
                modal.style.alignItems = 'center';
                
                const messageBox = document.createElement('div');
                messageBox.style.backgroundColor = 'white';
                messageBox.style.padding = '20px';
                messageBox.style.borderRadius = '8px';
                messageBox.style.maxWidth = '500px';
                messageBox.style.textAlign = 'center';
                messageBox.innerHTML = `
                    <h3 style="margin-top: 0; color: #2c7be5;">Operation Video Export</h3>
                    <p>Please select your preferred view before starting the recording.</p>
                    <div style="display: flex; justify-content: space-around; margin-bottom: 15px;">
                        <button id="setTopView" class="view-btn">Top View</button>
                        <button id="setFrontView" class="view-btn">Front View</button>
                        <button id="setSideView" class="view-btn">Side View</button>
                        <button id="setIsoView" class="view-btn">3D View</button>
                    </div>
                    
                    <div style="margin: 15px 0; text-align: left;">
                        <div style="margin-bottom: 10px;">
                            <label for="videoQuality" style="display: block; margin-bottom: 5px; font-weight: bold;">Video Quality:</label>
                            <select id="videoQuality" style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #ddd;">
                                <option value="low">Low (720p)</option>
                                <option value="medium" selected>Medium (1080p)</option>
                                <option value="high">High (1440p)</option>
                                <option value="ultra">Ultra HD (2160p)</option>
                            </select>
                        </div>
                        
                        <div style="margin-bottom: 10px;">
                            <label for="frameRate" style="display: block; margin-bottom: 5px; font-weight: bold;">Frame Rate:</label>
                            <select id="frameRate" style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #ddd;">
                                <option value="24">24 FPS (Cinematic)</option>
                                <option value="30" selected>30 FPS (Standard)</option>
                                <option value="60">60 FPS (Smooth)</option>
                            </select>
                        </div>
                        
                        <div style="margin-bottom: 10px;">
                            <label for="exportFormat" style="display: block; margin-bottom: 5px; font-weight: bold;">Export Format:</label>
                            <select id="exportFormat" style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #ddd;">
                                <option value="webm" selected>WebM (VP9)</option>
                                <option value="mp4">MP4 (H.264)</option>
                            </select>
                        </div>
                        
                        <div style="margin-bottom: 10px;">
                            <label for="canvasArea" style="display: block; margin-bottom: 5px; font-weight: bold;">Canvas Area:</label>
                            <select id="canvasArea" style="width: 100%; padding: 8px; border-radius: 4px; border: 1px solid #ddd;">
                                <option value="full" selected>Full Canvas</option>
                                <option value="model">Model Only (Auto-crop)</option>
                            </select>
                        </div>
                    </div>
                    
                    <p>Current status: <span id="recordingStatus">Ready to record</span></p>
                    <div style="margin-top: 15px;">
                        <button id="startRecordingBtn" style="background-color: #2c7be5; color: white; padding: 10px 15px; border: none; border-radius: 4px; margin-right: 10px;">Start Recording</button>
                        <button id="stopRecordingBtn" style="background-color: #e53935; color: white; padding: 10px 15px; border: none; border-radius: 4px; display: none;">Stop Recording</button>
                        <button id="cancelRecordingBtn" style="background-color: #777; color: white; padding: 10px 15px; border: none; border-radius: 4px; margin-left: 10px;">Cancel</button>
                    </div>
                `;
                
                // Add some styling for view buttons
                const style = document.createElement('style');
                style.textContent = `
                    .view-btn {
                        background-color: #f0f0f0;
                        border: 1px solid #ddd;
                        padding: 5px 10px;
                        border-radius: 4px;
                        cursor: pointer;
                    }
                    .view-btn:hover {
                        background-color: #e0e0e0;
                    }
                    .view-btn.active {
                        background-color: #2c7be5;
                        color: white;
                    }
                `;
                document.head.appendChild(style);
                
                modal.appendChild(messageBox);
                document.body.appendChild(modal);
                
                // Variables for recording
                let mediaRecorder;
                let recordedChunks = [];
                let canvasStream;
                let tempRenderer;
                
                // Update view button states
                function updateViewButtons() {
                    document.querySelectorAll('.view-btn').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    
                    const activeViewBtn = document.getElementById(`set${currentView.charAt(0).toUpperCase() + currentView.slice(1)}View`);
                    if (activeViewBtn) {
                        activeViewBtn.classList.add('active');
                    }
                }
                
                // Set up event listeners for view selection
                document.getElementById('setTopView').addEventListener('click', () => {
                    currentView = 'top';
                    updateView();
                    updateViewButtons();
                });
                
                document.getElementById('setFrontView').addEventListener('click', () => {
                    currentView = 'front';
                    updateView();
                    updateViewButtons();
                });
                
                document.getElementById('setSideView').addEventListener('click', () => {
                    currentView = 'side';
                    updateView();
                    updateViewButtons();
                });
                
                document.getElementById('setIsoView').addEventListener('click', () => {
                    currentView = 'iso';
                    updateView();
                    updateViewButtons();
                });
                
                // Initialize active view
                updateViewButtons();
                
                // Cancel button
                document.getElementById('cancelRecordingBtn').addEventListener('click', () => {
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        mediaRecorder.stop();
                    }
                    
                    if (canvasStream) {
                        canvasStream.getTracks().forEach(track => track.stop());
                    }
                    
                    stopOperation();
                    document.body.removeChild(modal);
                    document.head.removeChild(style);
                });
                
                // Start recording button
                document.getElementById('startRecordingBtn').addEventListener('click', async () => {
                    try {
                        // Get selected options
                        const qualitySelect = document.getElementById('videoQuality');
                        const frameRateSelect = document.getElementById('frameRate');
                        const formatSelect = document.getElementById('exportFormat');
                        const canvasAreaSelect = document.getElementById('canvasArea');
                        
                        const quality = qualitySelect.value;
                        const frameRate = parseInt(frameRateSelect.value);
                        const format = formatSelect.value;
                        const canvasArea = canvasAreaSelect.value;
                        
                        // Set resolution based on quality
                        let width, height;
                        switch(quality) {
                            case 'low':
                                width = 1280; height = 720; // 720p
                                break;
                            case 'medium':
                                width = 1920; height = 1080; // 1080p
                                break;
                            case 'high':
                                width = 2560; height = 1440; // 1440p
                                break;
                            case 'ultra':
                                width = 3840; height = 2160; // 4K
                                break;
                            default:
                                width = 1920; height = 1080; // Default to 1080p
                        }
                        
                        // Set up the recording canvas
                        let recordingCanvas;
                        const mainCanvas = document.querySelector('#canvas');
                        
                        if (canvasArea === 'model') {
                            // For model-only recording, we'll use a THREE.js renderer
                            // Create a temporary container for rendering
                            const tempContainer = document.createElement('div');
                            tempContainer.style.position = 'absolute';
                            tempContainer.style.left = '-9999px';
                            document.body.appendChild(tempContainer);
                            
                            // Create high-resolution renderer
                            tempRenderer = new THREE.WebGLRenderer({
                                antialias: true,
                                preserveDrawingBuffer: true,
                                alpha: true
                            });
                            tempRenderer.setSize(width, height);
                            tempRenderer.setClearColor(0xFFFFFF, 1);
                            tempContainer.appendChild(tempRenderer.domElement);
                            
                            recordingCanvas = tempRenderer.domElement;
                        } else {
                            // For full canvas, we'll use the existing canvas but at higher resolution
                            recordingCanvas = mainCanvas;
                        }
                        
                        // Set up streaming from the canvas
                        canvasStream = recordingCanvas.captureStream(frameRate);
                        
                        // Determine MIME type and codecs based on format
                        let mimeType, fileExtension;
                        if (format === 'mp4' && MediaRecorder.isTypeSupported('video/mp4')) {
                            mimeType = 'video/mp4';
                            fileExtension = 'mp4';
                        } else {
                            // Default to WebM if MP4 is not supported
                            mimeType = 'video/webm;codecs=vp9';
                            fileExtension = 'webm';
                        }
                        
                        // Create media recorder with high bitrate for better quality
                        const options = {
                            mimeType: mimeType,
                            videoBitsPerSecond: quality === 'ultra' ? 8000000 : 
                                               quality === 'high' ? 5000000 : 
                                               quality === 'medium' ? 2500000 : 1000000
                        };
                        
                        mediaRecorder = new MediaRecorder(canvasStream, options);
                        
                        // Set up recording events
                        mediaRecorder.ondataavailable = (event) => {
                            if (event.data.size > 0) {
                                recordedChunks.push(event.data);
                            }
                        };
                        
                        mediaRecorder.onstop = () => {
                            // Create a blob from the recorded chunks
                            const blob = new Blob(recordedChunks, { type: mimeType });
                            const url = URL.createObjectURL(blob);
                            
                            // Create a download link
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = `elevator_operation_${quality}_${frameRate}fps.${fileExtension}`;
                            a.click();
                            
                            // Clean up
                            URL.revokeObjectURL(url);
                            recordedChunks = [];
                            document.getElementById('recordingStatus').textContent = 'Recording complete';
                            
                            // Clean up temporary renderer if used
                            if (canvasArea === 'model' && tempRenderer) {
                                const tempContainer = tempRenderer.domElement.parentNode;
                                if (tempContainer && tempContainer.parentNode) {
                                    document.body.removeChild(tempContainer);
                                }
                                tempRenderer.dispose();
                                tempRenderer = null;
                            }
                            
                            // Stop operation
                            stopOperation();
                            
                            // Enable start button
                            document.getElementById('startRecordingBtn').style.display = 'inline-block';
                            document.getElementById('stopRecordingBtn').style.display = 'none';
                        };
                        
                        // Update UI
                        document.getElementById('startRecordingBtn').style.display = 'none';
                        document.getElementById('stopRecordingBtn').style.display = 'inline-block';
                        document.getElementById('recordingStatus').textContent = 'Recording...';
                        
                        // Set up rendering loop for model-only recording
                        if (canvasArea === 'model') {
                            const renderLoop = () => {
                                if (mediaRecorder && mediaRecorder.state === 'recording') {
                                    tempRenderer.render(scene, camera);
                                    requestAnimationFrame(renderLoop);
                                }
                            };
                            renderLoop();
                        }
                        
                        // Start recording with larger time slices for better quality
                        mediaRecorder.start(1000); // 1 second time slices
                        
                        // Start elevator operation
                        startOperation();
                        
                    } catch (error) {
                        console.error('Recording error:', error);
                        alert('Error starting recording: ' + error.message);
                        document.getElementById('recordingStatus').textContent = 'Error: ' + error.message;
                    }
                });
                
                // Stop recording button
                document.getElementById('stopRecordingBtn').addEventListener('click', () => {
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        mediaRecorder.stop();
                        if (canvasStream) {
                            canvasStream.getTracks().forEach(track => track.stop());
                        }
                        document.getElementById('recordingStatus').textContent = 'Processing...';
                    }
                });
                
                // Update the cancel button to clean up any temporary renderers
                document.getElementById('cancelRecordingBtn').addEventListener('click', () => {
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        mediaRecorder.stop();
                    }
                    
                    if (canvasStream) {
                        canvasStream.getTracks().forEach(track => track.stop());
                    }
                    
                    // Clean up temporary renderer if used
                    if (tempRenderer) {
                        const tempContainer = tempRenderer.domElement.parentNode;
                        if (tempContainer && tempContainer.parentNode) {
                            document.body.removeChild(tempContainer);
                        }
                        tempRenderer.dispose();
                        tempRenderer = null;
                    }
                    
                    stopOperation();
                    document.body.removeChild(modal);
                    document.head.removeChild(style);
                });
                
            } catch (error) {
                console.error('Video export error:', error);
                alert('Error setting up video export: ' + error.message);
            }
        }
        
        async function exportAsPDF() {
            try {
                const originalView = currentView;
                const originalMeasurements = showMeasurements;
                
                // Hide measurements temporarily
                showMeasurements = false;
                updateMeasurements();
                
                // Create a PDF document
                const { jspdf } = window.jspdf;
                const doc = new jspdf.jsPDF('landscape', 'mm', 'a4');
                
                // Add project title
                const pageWidth = doc.internal.pageSize.getWidth();
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(18);
                doc.text('Advanced Goods Elevator - Design Documents', pageWidth / 2, 20, { align: 'center' });
                
                // Add views
                const views = [
                    { name: 'Top View', type: 'top' },
                    { name: 'Front View', type: 'front' },
                    { name: 'Side View', type: 'side' },
                    { name: '3D View', type: 'iso' }
                ];
                
                // Set up page layout vars
                const margin = 10;
                const availableWidth = pageWidth - 2 * margin;
                const topViewHeight = 70; // mm
                const remainingViews = (doc.internal.pageSize.getHeight() - 30 - topViewHeight - margin) / 2; // mm
                
                // First page - views
                let currentPage = 1;
                let yPos = 30; // Start position after title
                
                // Capture and add the views to PDF
                for (let i = 0; i < views.length; i++) {
                    // Switch to the view
                    currentView = views[i].type;
                    updateView();
                    
                    // Wait for the view to render
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // Always show top level indicator in exports
                    if (topLevelIndicator) topLevelIndicator.visible = true;
                    
                    // Capture the canvas as an image
                    const canvas = await html2canvas(document.querySelector('#canvas'), {
                        scale: 2,
                        backgroundColor: '#FFFFFF',
                        logging: false,
                        useCORS: true
                    });
                    
                    // Get the image as a data URL
                    const imgData = canvas.toDataURL('image/jpeg', 0.9);
                    
                    // Add heading for the view
                    doc.setFont('helvetica', 'bold');
                    doc.setFontSize(12);
                    doc.text(views[i].name, margin, yPos);
                    
                    // Add the image to the PDF
                    let imgWidth, imgHeight;
                    if (i === 0) { // Top view gets more vertical space
                        imgWidth = availableWidth;
                        imgHeight = topViewHeight;
                        doc.addImage(imgData, 'JPEG', margin, yPos + 5, imgWidth, imgHeight);
                        yPos += imgHeight + 15;
                    } else { // Other views share the remaining space
                        imgWidth = availableWidth / 2 - 5;
                        imgHeight = remainingViews;
                        
                        if (i === 1) { // Front view (left)
                            doc.addImage(imgData, 'JPEG', margin, yPos + 5, imgWidth, imgHeight);
                        } else if (i === 2) { // Side view (right)
                            doc.addImage(imgData, 'JPEG', margin + imgWidth + 10, yPos + 5, imgWidth, imgHeight);
                            yPos += imgHeight + 15;
                        } else if (i === 3) { // 3D view (bottom)
                            if (yPos + imgHeight + 10 > doc.internal.pageSize.getHeight() - margin) {
                                doc.addPage();
                                currentPage++;
                                yPos = 20;
                            }
                            doc.addImage(imgData, 'JPEG', margin, yPos + 5, availableWidth, imgHeight);
                        }
                    }
                }
                
                // Second page - specifications and BOQ/BOM
                doc.addPage();
                
                // Add specifications title
                yPos = 20;
                doc.setFont('helvetica', 'bold');
                doc.setFontSize(16);
                doc.text('Technical Specifications', margin, yPos);
                
                // Add specifications
                yPos += 10;
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(11);
                doc.text(`Cabin Width: ${document.getElementById('elevatorWidth').value} mm`, margin, yPos);
                yPos += 7;
                doc.text(`Cabin Depth: ${document.getElementById('elevatorDepth').value} mm`, margin, yPos);
                yPos += 7;
                doc.text(`Cabin Height: ${document.getElementById('elevatorHeight').value} mm`, margin, yPos);
                yPos += 7;
                doc.text(`Shaft Height: ${document.getElementById('shaftHeight').value} mm`, margin, yPos);
                yPos += 7;
                doc.text(`Floor Count: ${document.getElementById('floorCount').value}`, margin, yPos);
                yPos += 7;
                doc.text(`Column Type: ${document.getElementById('columnType').selectedOptions[0].text}`, margin, yPos);
                yPos += 7;
                doc.text(`Door Type: ${document.getElementById('doorType').selectedOptions[0].text}`, margin, yPos);
                
                // Save the PDF
                doc.save('elevator_design.pdf');
                
                // Restore original view and settings
                currentView = originalView;
                showMeasurements = originalMeasurements;
                updateView();
                updateMeasurements();
                
                alert('PDF export completed successfully!');
            } catch (error) {
                console.error('PDF export error:', error);
                alert('Error exporting PDF: ' + error.message);
            }
        }
        // ===== NEW EXPORT FUNCTIONS END HERE =====
        
        // Initialize the designer
        // Create motor hanging structure
        function createMotorStructure() {
            // Clear previous motor structure
            motorGroup.clear();
            topBeam = null;
            
            const motorConfig = document.getElementById('motorConfig').value;
            if (motorConfig === 'none' || columns.length < 4) return;
            
            const width = parseInt(document.getElementById('elevatorWidth').value) * 0.001;
            const depth = parseInt(document.getElementById('elevatorDepth').value) * 0.001;
            const height = parseInt(document.getElementById('shaftHeight').value) * 0.001;
            const columnType = document.getElementById('columnType').value;
            const motorOffset = parseInt(document.getElementById('motorOffset').value) * 0.001;
            const enableVerticalSupport = document.getElementById('enableVerticalSupport').checked;
            const topBeamRotation = parseInt(document.getElementById('topBeamRotation').value);
            
            // Get column positions (assuming 4 columns in order: front-left, front-right, back-left, back-right)
            if (columns.length < 4) return;
            
            // Extract column positions
            const columnPositions = columns.map(column => {
                return {
                    x: column.position.x,
                    y: column.position.y,
                    z: column.position.z
                };
            });
            
            // Get profile data based on column type
            const profileData = getProfileData(columnType);
            const motorMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, metalness: 0.7, roughness: 0.3 });
            
            // Calculate the vertical position (top of shaft minus offset)
            const verticalPosition = height - motorOffset;
            
            if (motorConfig === 'leftRight') {
                // Left beam (front-left to back-left)
                const leftBeam = createMotorBeam(
                    new THREE.Vector3(columnPositions[0].x, verticalPosition, columnPositions[0].z),
                    new THREE.Vector3(columnPositions[2].x, verticalPosition, columnPositions[2].z),
                    profileData,
                    motorMaterial
                );
                motorGroup.add(leftBeam);
                
                // Right beam (front-right to back-right)
                const rightBeam = createMotorBeam(
                    new THREE.Vector3(columnPositions[1].x, verticalPosition, columnPositions[1].z),
                    new THREE.Vector3(columnPositions[3].x, verticalPosition, columnPositions[3].z),
                    profileData,
                    motorMaterial
                );
                motorGroup.add(rightBeam);
                
                // Calculate midpoints for cross beam
                const leftMid = new THREE.Vector3().lerpVectors(
                    new THREE.Vector3(columnPositions[0].x, verticalPosition, columnPositions[0].z),
                    new THREE.Vector3(columnPositions[2].x, verticalPosition, columnPositions[2].z),
                    0.5
                );
                
                const rightMid = new THREE.Vector3().lerpVectors(
                    new THREE.Vector3(columnPositions[1].x, verticalPosition, columnPositions[1].z),
                    new THREE.Vector3(columnPositions[3].x, verticalPosition, columnPositions[3].z),
                    0.5
                );
                
                // Calculate the height of the beams to position the cross beam on top
                const beamHeight = getBeamHeight(profileData);
                
                // Adjust the cross beam position to be on top of the other beams
                const crossBeamPosition = new THREE.Vector3().lerpVectors(leftMid, rightMid, 0.5);
                crossBeamPosition.y += beamHeight; // Position on top of the other beams
                
                // Cross beam (left to right)
                const crossBeam = createMotorBeam(
                    new THREE.Vector3(leftMid.x, crossBeamPosition.y, leftMid.z),
                    new THREE.Vector3(rightMid.x, crossBeamPosition.y, rightMid.z),
                    profileData,
                    motorMaterial
                );
                
                // Store reference to the top beam
                topBeam = crossBeam;
                
                // Apply initial rotation
                updateTopBeamRotation(topBeamRotation);
                
                motorGroup.add(crossBeam);
                
                // Add vertical support if needed
                if (enableVerticalSupport) {
                    const verticalBeam = createMotorBeam(
                        crossBeamPosition,
                        new THREE.Vector3(crossBeamPosition.x, 0, crossBeamPosition.z),
                        profileData,
                        motorMaterial
                    );
                    motorGroup.add(verticalBeam);
                }
                
            } else if (motorConfig === 'frontBack') {
                // Front beam (front-left to front-right)
                const frontBeam = createMotorBeam(
                    new THREE.Vector3(columnPositions[0].x, verticalPosition, columnPositions[0].z),
                    new THREE.Vector3(columnPositions[1].x, verticalPosition, columnPositions[1].z),
                    profileData,
                    motorMaterial
                );
                motorGroup.add(frontBeam);
                
                // Back beam (back-left to back-right)
                const backBeam = createMotorBeam(
                    new THREE.Vector3(columnPositions[2].x, verticalPosition, columnPositions[2].z),
                    new THREE.Vector3(columnPositions[3].x, verticalPosition, columnPositions[3].z),
                    profileData,
                    motorMaterial
                );
                motorGroup.add(backBeam);
                
                // Calculate midpoints for cross beam
                const frontMid = new THREE.Vector3().lerpVectors(
                    new THREE.Vector3(columnPositions[0].x, verticalPosition, columnPositions[0].z),
                    new THREE.Vector3(columnPositions[1].x, verticalPosition, columnPositions[1].z),
                    0.5
                );
                
                const backMid = new THREE.Vector3().lerpVectors(
                    new THREE.Vector3(columnPositions[2].x, verticalPosition, columnPositions[2].z),
                    new THREE.Vector3(columnPositions[3].x, verticalPosition, columnPositions[3].z),
                    0.5
                );
                
                // Calculate the height of the beams to position the cross beam on top
                const beamHeight = getBeamHeight(profileData);
                
                // Adjust the cross beam position to be on top of the other beams
                const crossBeamPosition = new THREE.Vector3().lerpVectors(frontMid, backMid, 0.5);
                crossBeamPosition.y += beamHeight; // Position on top of the other beams
                
                // Cross beam (front to back)
                const crossBeam = createMotorBeam(
                    new THREE.Vector3(frontMid.x, crossBeamPosition.y, frontMid.z),
                    new THREE.Vector3(backMid.x, crossBeamPosition.y, backMid.z),
                    profileData,
                    motorMaterial
                );
                
                // Store reference to the top beam
                topBeam = crossBeam;
                
                // Apply initial rotation
                updateTopBeamRotation(topBeamRotation);
                
                motorGroup.add(crossBeam);
                
                // Add vertical support if needed
                if (enableVerticalSupport) {
                    const verticalBeam = createMotorBeam(
                        crossBeamPosition,
                        new THREE.Vector3(crossBeamPosition.x, 0, crossBeamPosition.z),
                        profileData,
                        motorMaterial
                    );
                    motorGroup.add(verticalBeam);
                }
            }
        }
        
        // Get profile data based on column type
        function getProfileData(columnType) {
            switch(columnType) {
                case 'hbeam100':
                    return { type: 'hbeam', width: 0.1, height: 0.1, flangeThickness: 0.008, webThickness: 0.006 };
                case 'hbeam200':
                    return { type: 'hbeam', width: 0.2, height: 0.2, flangeThickness: 0.012, webThickness: 0.008 };
                case 'hbeam300':
                    return { type: 'hbeam', width: 0.3, height: 0.3, flangeThickness: 0.015, webThickness: 0.01 };
                case 'rectTube100x50':
                    return { type: 'rectTube', width: 0.1, height: 0.05, thickness: 0.00635 };
                case 'rectTube150x75':
                    return { type: 'rectTube', width: 0.15, height: 0.075, thickness: 0.00635 };
                case 'cChannel80':
                    return { type: 'cChannel', width: 0.08, height: 0.04, flangeThickness: 0.008, webThickness: 0.006 };
                case 'cChannel100':
                    return { type: 'cChannel', width: 0.1, height: 0.05, flangeThickness: 0.01, webThickness: 0.006 };
                case 'cChannel150':
                    return { type: 'cChannel', width: 0.15, height: 0.075, flangeThickness: 0.012, webThickness: 0.006 };
                case 'lAngle50x50':
                    return { type: 'lAngle', width: 0.05, height: 0.05, thickness: 0.005 };
                case 'lAngle75x75':
                    return { type: 'lAngle', width: 0.075, height: 0.075, thickness: 0.006 };
                case 'lAngle100x100':
                    return { type: 'lAngle', width: 0.1, height: 0.1, thickness: 0.008 };
                case 'central':
                    return { type: 'hbeam', width: 0.2, height: 0.2, flangeThickness: 0.012, webThickness: 0.008 };
                default:
                    return { type: 'hbeam', width: 0.2, height: 0.2, flangeThickness: 0.012, webThickness: 0.008 };
            }
        }
        
        // Get the height of the beam based on profile data
        function getBeamHeight(profileData) {
            // For H-beams and rectangular tubes, use the height dimension
            if (profileData.type === 'hbeam' || profileData.type === 'rectTube') {
                return profileData.height;
            }
            // For C-channels and L-angles, use the height dimension
            return profileData.height;
        }
        
        // Create a motor beam between two points
        function createMotorBeam(start, end, profileData, material) {
            const direction = new THREE.Vector3().subVectors(end, start);
            const length = direction.length();
            const center = new THREE.Vector3().lerpVectors(start, end, 0.5);
            
            let beam;
            
            if (profileData.type === 'hbeam') {
                beam = createHBeamColumn(profileData.width, profileData.height, 
                                       profileData.flangeThickness, profileData.webThickness, 
                                       length);
            } else if (profileData.type === 'rectTube') {
                beam = createRectangularTube(profileData.width, profileData.height, 
                                           profileData.thickness, length);
            } else if (profileData.type === 'cChannel') {
                beam = createCChannel(profileData.width, profileData.height, 
                                    profileData.flangeThickness, profileData.webThickness, 
                                    length);
            } else if (profileData.type === 'lAngle') {
                beam = createLAngle(profileData.width, profileData.height, 
                                  profileData.thickness, length);
            }
            
            // Position and rotate the beam
            beam.position.copy(center);
            
            // Calculate rotation to align with direction vector
            const axis = new THREE.Vector3(0, 1, 0); // Default vertical axis
            const rotationAxis = new THREE.Vector3().crossVectors(axis, direction).normalize();
            const angle = Math.acos(axis.dot(direction.clone().normalize()));
            
            if (rotationAxis.length() > 0) { // Avoid NaN when direction is parallel to axis
                beam.quaternion.setFromAxisAngle(rotationAxis, angle);
            }
            
            // Apply material
            beam.traverse(child => {
                if (child.isMesh) {
                    child.material = material;
                }
            });
            
            return beam;
        }
        
        // Update the top beam rotation
        function updateTopBeamRotation(angle) {
            if (topBeam) {
                // Convert angle to radians
                const radians = angle * Math.PI / 180;
                
                // Reset rotation first
                topBeam.rotation.set(0, 0, 0);
                
                // Apply the standard rotations to make it horizontal along its axis
                const motorConfig = document.getElementById('motorConfig').value;
                
                if (motorConfig === 'leftRight') {
                    // For left/right config, the beam is along X-axis
                    topBeam.rotation.z = Math.PI/2; // Make it horizontal along X-axis
                    // Then apply the rotation around its own axis (X-axis)
                    topBeam.rotation.x = radians;
                } else if (motorConfig === 'frontBack') {
                    // For front/back config, the beam is along Z-axis
                    topBeam.rotation.x = Math.PI/2; // Make it horizontal along Z-axis
                    // Then apply the rotation around its own axis (Z-axis)
                    topBeam.rotation.y = radians;
                }
            }
        }
        
        function init() {
            console.log("Initializing designer");
            setupCanvas();
            setupEventListeners();
            createElevator();
            generateFloors();
            updateMeasurements();
            animate(); // Start animation loop
            setupViewListeners();
            updateFloorVisibilityButtons();
            updateAllValueDisplays(); // Ensure all value displays are properly initialized
            
            // Initialize horizontal beam controls
            document.getElementById('horizontalBeamSections').addEventListener('input', function(e) {
                document.getElementById('horizontalBeamSectionsValue').textContent = e.target.value;
                createElevator();
            });
            
            document.getElementById('horizontalBeamType').addEventListener('change', function() {
                createElevator();
            });
            
            document.getElementById('enableDiagonalSupports').addEventListener('change', function() {
                createElevator();
            });
            
            // Motor hanging structure event listeners
            document.getElementById('motorConfig').addEventListener('change', function() {
                createElevator();
            });
            
            document.getElementById('motorOffset').addEventListener('input', function(e) {
                document.getElementById('motorOffsetValue').textContent = e.target.value;
                createElevator();
            });
            
            document.getElementById('enableVerticalSupport').addEventListener('change', function() {
                createElevator();
            });
            
            document.getElementById('topBeamRotation').addEventListener('input', function(e) {
                const angle = parseInt(e.target.value);
                document.getElementById('topBeamRotationValue').textContent = angle;
                updateTopBeamRotation(angle);
            });
            
            // Force initial column updates
            setTimeout(function() {
                console.log("Forcing initial column updates");
                forceUpdateColumns();
                // Initialize column rotation controls
                const columnCount = parseInt(document.getElementById('columnCount').value);
                updateColumnRotationControls(columnCount);
            }, 1000);
            
            // Initialize roller door
            initRollerDoor();
            
            // Add door controls
            const doorControls = document.createElement('div');
            doorControls.className = 'control-group';
            doorControls.innerHTML = `
                <h3>Roller Door Controls</h3>
                <button onclick="toggleRollerDoor()">Toggle Door</button>
                <div class="door-preview">
                    <p>Door Status: <span id="doorStatus">Closed</span></p>
                </div>
            `;
            document.getElementById('designer-panel').appendChild(doorControls);
        }
        
        // Set up the canvas and renderer
        function setupCanvas() {
            const canvas = document.getElementById('canvas');
            canvas.width = document.getElementById('viewport').clientWidth;
            canvas.height = document.getElementById('viewport').clientHeight;
            
            renderer = new THREE.WebGLRenderer({ 
                canvas: canvas,
                antialias: true,
                alpha: true
            });
            renderer.setClearColor(0xf9f9f9, 1);
            renderer.setSize(canvas.width, canvas.height);
            
            scene = new THREE.Scene();
            
            // Set up orthographic camera for 2D views
            camera = new THREE.PerspectiveCamera(60, canvas.width / canvas.height, 0.1, 10000);
            camera.position.set(50, 50, 50);
            camera.lookAt(0, 0, 0);
            
           controls = new THREE.OrbitControls(camera, renderer.domElement);
controls.target.set(0, parseInt(document.getElementById('shaftHeight').value) * 0.0005, 0);
controls.enableDamping = true;
            
            // Add grid helper
            const gridHelper = new THREE.GridHelper(10, 10, 0xcccccc, 0xcccccc);
            scene.add(gridHelper);
            
            // Add axes helper
            const axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);
            
            // Add ambient light
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            // Add directional light
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(50, 200, 100);
            scene.add(directionalLight);
        }
        
        // Create the elevator structure
        function createElevator() {
            // Clear previous elements
            if (elevatorGroup) scene.remove(elevatorGroup);
            
            // Remove motor group from scene first
            scene.remove(motorGroup);
            
            elevatorGroup = new THREE.Group();
            
            // Create columns at correct positions
            createColumns();
            
            // Create platform (fixed at ground level)
            createPlatform();
            
            // Create cage structure (stays stationary with the columns) only if enabled
            if (document.getElementById('enableCage').checked) {
                const cage = createCage();
                elevatorGroup.add(cage);
            }
            
            // Create cabin
            createCabin();
            
            // Create cabin frame with rectangular steel tubes
            createCabinFrame();
            
            // Create doors
            createDoors();
            
            // Add elevator group to scene
            scene.add(elevatorGroup);
            
            // Create motor hanging structure if needed
            createMotorStructure();
            
            // Add motor group to scene separately
            scene.add(motorGroup);
            
            // Update measurements
            updateMeasurements();
        }
        
        function createHBeamColumn(width, height, flangeThickness, webThickness, length) {
            const group = new THREE.Group();
            const material = new THREE.MeshStandardMaterial({
                color: 0x7f8c8d,
                metalness: 0.4,
                roughness: 0.6
            });

            // Create the H cross-section shape
            const hShape = new THREE.Shape();
            
            // Start at bottom left
            hShape.moveTo(-width/2, -height/2);
            
            // Bottom flange
            hShape.lineTo(width/2, -height/2);
            hShape.lineTo(width/2, -height/2 + flangeThickness);
            
            // Web right side
            hShape.lineTo(webThickness/2, -height/2 + flangeThickness);
            hShape.lineTo(webThickness/2, height/2 - flangeThickness);
            
            // Top flange right side
            hShape.lineTo(width/2, height/2 - flangeThickness);
            hShape.lineTo(width/2, height/2);
            
            // Top flange left side
            hShape.lineTo(-width/2, height/2);
            hShape.lineTo(-width/2, height/2 - flangeThickness);
            
            // Web left side
            hShape.lineTo(-webThickness/2, height/2 - flangeThickness);
            hShape.lineTo(-webThickness/2, -height/2 + flangeThickness);
            
            // Close the shape
            hShape.lineTo(-width/2, -height/2 + flangeThickness);
            hShape.lineTo(-width/2, -height/2);

            // Extrude the shape
            const extrudeSettings = {
                steps: 1,
                depth: length,
                bevelEnabled: false
            };

            const geometry = new THREE.ExtrudeGeometry(hShape, extrudeSettings);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.rotation.x = Math.PI/2; // Rotate to stand upright
            mesh.position.y = length/2; // Center vertically

            group.add(mesh);
            return group;
        }
        
        function createRectangularTube(width, height, thickness, length) {
            const group = new THREE.Group();
            const material = new THREE.MeshStandardMaterial({
                color: 0x777777,
                metalness: 0.7,
                roughness: 0.3
            });

            // Create outer box
            const outerGeometry = new THREE.BoxGeometry(width, height, length);
            const outerMesh = new THREE.Mesh(outerGeometry, material);
            
            // Create inner box (for hollow section)
            const innerWidth = width - thickness * 2;
            const innerHeight = height - thickness * 2;
            const innerGeometry = new THREE.BoxGeometry(innerWidth, innerHeight, length + 0.01);
            const innerMesh = new THREE.Mesh(innerGeometry, material);
            innerMesh.position.z = 0.005; // Slight offset to prevent z-fighting
            
            // Create hollow tube by combining outer and inner
            const tube = new THREE.Group();
            tube.add(outerMesh);
            tube.add(innerMesh);
            
            // Rotate to stand upright
            tube.rotation.x = Math.PI/2;
            tube.position.y = length/2;
            
            group.add(tube);
            return group;
        }
        
          function createCChannel(width, height, flangeThickness, webThickness, length) {
            const group = new THREE.Group();
            const material = new THREE.MeshStandardMaterial({
                color: 0x7f8c8d,
                metalness: 0.4,
                roughness: 0.6
            });

            // Create the C cross-section shape using the improved method
            const shape = new THREE.Shape();
            
            // Start at bottom left
            shape.moveTo(0, 0);
            shape.lineTo(0, height);
            shape.lineTo(flangeThickness, height);
            shape.lineTo(flangeThickness, webThickness);
            shape.lineTo(width - flangeThickness, webThickness);
            shape.lineTo(width - flangeThickness, height);
            shape.lineTo(width, height);
            shape.lineTo(width, 0);
            shape.closePath();

            // Extrude the shape
            const extrudeSettings = {
                steps: 1,
                depth: length,
                bevelEnabled: false
            };

            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            
            // Rotate to stand upright (vertical orientation for columns)
            geometry.rotateX(Math.PI/2); // Rotate around X axis to make it vertical
            geometry.rotateY(Math.PI);   // Rotate around Y to face the open side inward
            
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.y = length/2; // Center vertically
            
            // For C-channels, we need to rotate them to face the open side toward the cabin
            // This will be handled when positioning the columns
            group.add(mesh);
            return group;
        
        }
        
        function createLAngle(width, height, thickness, length) {
            const group = new THREE.Group();
            const material = new THREE.MeshStandardMaterial({
                color: 0x7f8c8d,
                metalness: 0.4,
                roughness: 0.6
            });

            // Create the L cross-section shape
            const lShape = new THREE.Shape();
            
            // Start at bottom left
            lShape.moveTo(-width/2, -height/2);
            
            // Bottom flange
            lShape.lineTo(width/2, -height/2);
            lShape.lineTo(width/2, -height/2 + thickness);
            
            // Vertical part
            lShape.lineTo(-width/2 + thickness, -height/2 + thickness);
            lShape.lineTo(-width/2 + thickness, height/2);
            
            // Top flange
            lShape.lineTo(-width/2, height/2);
            lShape.lineTo(-width/2, -height/2);

            // Extrude the shape
            const extrudeSettings = {
                steps: 1,
                depth: length,
                bevelEnabled: false
            };

            const geometry = new THREE.ExtrudeGeometry(lShape, extrudeSettings);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.rotation.x = Math.PI/2; // Rotate to stand upright
            mesh.position.y = length/2; // Center vertically

            group.add(mesh);
            return group;
        }
        
        function createColumns() {
            // Remove existing columns
            columns.forEach(column => {
                if (column.geometry) column.geometry.dispose();
                if (column.material) column.material.dispose();
                elevatorGroup.remove(column);
            });
            columns = [];
            
            const width = parseInt(document.getElementById('elevatorWidth').value) * 0.001;
            const depth = parseInt(document.getElementById('elevatorDepth').value) * 0.001;
            const height = parseInt(document.getElementById('shaftHeight').value) * 0.001;
            const columnType = document.getElementById('columnType').value;
            const columnCount = parseInt(document.getElementById('columnCount').value);
            const columnOffset = parseInt(document.getElementById('columnOffset').value) * 0.001;
            
            // Get column position adjustments in millimeters and convert to meters
            const columnXPosition = parseInt(document.getElementById('columnXPosition').value) * 0.001;
            const columnZPosition = parseInt(document.getElementById('columnZPosition').value) * 0.001;
            
            // Skip if no columns
            if (columnType === 'none') return;
            
            // Calculate column positions based on elevator dimensions and offset
            let positions = [];
            
            if (columnCount === 2 && columnType === 'central') {
                // Two central columns
                positions = [
                    { x: 0, z: depth/2 + columnOffset, index: 0 },
                    { x: 0, z: -depth/2 - columnOffset, index: 1 }
                ];
            } else {
                // Four corner columns with adjustable positioning
                const xOffset = width/2 + columnOffset;
                const zOffset = depth/2 + columnOffset;
                
                // Apply the position adjustment in absolute values
                positions = [
                    { x: -xOffset + columnXPosition, z: zOffset - columnZPosition, index: 0 },   // Front Left
                    { x: xOffset - columnXPosition, z: zOffset - columnZPosition, index: 1 },    // Front Right
                    { x: -xOffset + columnXPosition, z: -zOffset + columnZPosition, index: 2 },  // Back Left
                    { x: xOffset - columnXPosition, z: -zOffset + columnZPosition, index: 3 }    // Back Right
                ];
                
                // Use only first two positions if column count is 2
                if (columnCount === 2) {
                    positions = positions.slice(0, 2);
                }
            }
            
            // Create columns with proper dimensions based on type
            positions.forEach(pos => {
                let column;
                let beamWidth, beamHeight, flangeThickness, webThickness;
                
                // Set dimensions based on column type
                if (columnType.includes('hbeam')) {
                    if (columnType === 'hbeam100') {
                        beamWidth = 0.1;
                        beamHeight = 0.1;
                        flangeThickness = 0.006;
                        webThickness = 0.008;
                    } else if (columnType === 'hbeam300') {
                        beamWidth = 0.3;
                        beamHeight = 0.3;
                        flangeThickness = 0.01;
                        webThickness = 0.015;
                    } else { // Default hbeam200
                        beamWidth = 0.2;
                        beamHeight = 0.2;
                        flangeThickness = 0.008;
                        webThickness = 0.012;
                    }
                    column = createHBeamColumn(beamWidth, beamHeight, flangeThickness, webThickness, height);
                } 
                else if (columnType.includes('rectTube')) {
                    if (columnType === 'rectTube100x50') {
                        beamWidth = 0.1;
                        beamHeight = 0.05;
                        flangeThickness = 0.00635;
                    } else { // rectTube150x75
                        beamWidth = 0.15;
                        beamHeight = 0.075;
                        flangeThickness = 0.00635;
                    }
                    column = createRectangularTube(beamWidth, beamHeight, flangeThickness, height);
                }
                else if (columnType.includes('cChannel')) {
                    if (columnType === 'cChannel80') {
                        beamWidth = 0.08;
                        beamHeight = 0.04;
                        flangeThickness = 0.006;
                        webThickness = 0.008;
                    } else if (columnType === 'cChannel150') {
                        beamWidth = 0.15;
                        beamHeight = 0.075;
                        flangeThickness = 0.006;
                        webThickness = 0.012;
                    } else { // cChannel100
                        beamWidth = 0.1;
                        beamHeight = 0.05;
                        flangeThickness = 0.006;
                        webThickness = 0.01;
                    }
                    column = createCChannel(beamWidth, beamHeight, flangeThickness, webThickness, height);
                    
                    // Rotate C-channel to face inward
                    if (pos.x < 0) {
                        column.rotation.y = Math.PI;
                    }
                    if (pos.z < 0) {
                        column.rotation.y = Math.PI / 2;
                    } else if (pos.z > 0) {
                        column.rotation.y = -Math.PI / 2;
                    }
                }
                else if (columnType.includes('lAngle')) {
                    if (columnType === 'lAngle50x50') {
                        beamWidth = 0.05;
                        beamHeight = 0.05;
                        flangeThickness = 0.005;
                    } else if (columnType === 'lAngle100x100') {
                        beamWidth = 0.1;
                        beamHeight = 0.1;
                        flangeThickness = 0.008;
                    } else { // lAngle75x75
                        beamWidth = 0.075;
                        beamHeight = 0.075;
                        flangeThickness = 0.006;
                    }
                    column = createLAngle(beamWidth, beamHeight, flangeThickness, height);
                    
                    // For L-angles, adjust rotation based on position
                    if (pos.x < 0 && pos.z > 0) { // Front left
                        column.rotation.y = 0;
                    } else if (pos.x > 0 && pos.z > 0) { // Front right
                        column.rotation.y = Math.PI / 2;
                    } else if (pos.x < 0 && pos.z < 0) { // Back left
                        column.rotation.y = -Math.PI / 2;
                    } else if (pos.x > 0 && pos.z < 0) { // Back right
                        column.rotation.y = Math.PI;
                    }
                }
                else if (columnType === 'central') {
                    column = createHBeamColumn(0.2, 0.2, 0.008, 0.012, height);
                    // Rotate central columns to face correctly
                    column.rotation.y = Math.PI / 2;
                }
                
                if (column) {
                    // Apply the column rotation from the rotation controls
                    if (columnRotations[pos.index]) {
                        column.rotation.y += columnRotations[pos.index] * Math.PI / 180;
                    }
                    
                    column.position.set(pos.x, height/2, pos.z);
                    elevatorGroup.add(column);
                    columns.push(column);
                }
            });
            
            // Update column rotation controls after creating columns
            updateColumnRotationControls(columnCount);
            
            // Create horizontal beams if needed
            const horizontalBeamSections = parseInt(document.getElementById('horizontalBeamSections').value);
            if (horizontalBeamSections > 0) {
                const horizontalBeamType = document.getElementById('horizontalBeamType').value;
                const enableDiagonalSupports = document.getElementById('enableDiagonalSupports').checked;
                
                // Create horizontal beams connecting the columns
                createHorizontalBeams(width, depth, height, horizontalBeamSections, horizontalBeamType, columnCount, columnType, columnOffset);
                
                // Calculate section height for display
                const sectionHeight = height / (horizontalBeamSections + 1);
                document.getElementById('sectionHeightValue').textContent = Math.round(sectionHeight * 1000);
                
                // Create diagonal supports if enabled
                if (enableDiagonalSupports) {
                    createDiagonalSupports(width, depth, height, horizontalBeamSections, columnCount, columnType);
                }
            }
        }
        
        function updateColumnRotationControls(columnCount) {
            const container = document.getElementById('columnRotationControls');
            container.innerHTML = '';
            
            for (let i = 0; i < columnCount; i++) {
                const div = document.createElement('div');
                div.innerHTML = `
                    <label for="columnAngle${i}">Column ${i+1} Angle:</label>
                    <input type="range" id="columnAngle${i}" min="-180" max="180" step="1" value="${columnRotations[i]}">
                    <div class="value-display"><span id="columnAngleValue${i}">${columnRotations[i]}</span>°</div>
                `;
                container.appendChild(div);
                
                // Add event listener
                document.getElementById(`columnAngle${i}`).addEventListener('input', function(e) {
                    columnRotations[i] = parseInt(e.target.value);
                    document.getElementById(`columnAngleValue${i}`).textContent = columnRotations[i];
                    createElevator();
                });
            }
            
            // Add event listener for unified rotation control
            document.getElementById('unifiedColumnRotation').addEventListener('input', function(e) {
                const angle = parseInt(e.target.value);
                document.getElementById('unifiedColumnRotationValue').textContent = angle;
                
                // Update all column rotations
                for (let i = 0; i < columnRotations.length; i++) {
                    columnRotations[i] = angle;
                    if (document.getElementById(`columnAngle${i}`)) {
                        document.getElementById(`columnAngle${i}`).value = angle;
                        document.getElementById(`columnAngleValue${i}`).textContent = angle;
                    }
                }
                
                createElevator();
            });
        }
        
        function createPlatform() {
            if (elevatorPlatform) elevatorGroup.remove(elevatorPlatform);
            
            const width = parseInt(document.getElementById('elevatorWidth').value) * 0.001;
            const depth = parseInt(document.getElementById('elevatorDepth').value) * 0.001;
            const thickness = 0.1; // Fixed platform thickness
            
            const geometry = new THREE.BoxGeometry(width, thickness, depth);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x333333,
                metalness: 0.2,
                roughness: 0.8
            });
            
            elevatorPlatform = new THREE.Mesh(geometry, material);
            elevatorPlatform.position.y = thickness/2; // Fixed at ground level
            elevatorGroup.add(elevatorPlatform);
        }
        
        function createCage() {
            const width = parseInt(document.getElementById('elevatorWidth').value) * 0.001;
            const depth = parseInt(document.getElementById('elevatorDepth').value) * 0.001;
            const shaftHeight = parseInt(document.getElementById('shaftHeight').value) * 0.001;
            const columnOffset = parseInt(document.getElementById('columnOffset').value) * 0.001;
            
            // Get the cage offset from the UI
            const cageOffset = parseInt(document.getElementById('cageOffset').value) * 0.001;
            
            // Add the cage offset to create larger cage dimensions
            const cageWidth = width + 2 * cageOffset;
            const cageDepth = depth + 2 * cageOffset;
            const cageHeight = shaftHeight;
            
            // Get or default door side
            const doorSideEl = document.getElementById('doorSide');
            const doorSide = doorSideEl ? doorSideEl.value : 'front';
            
            const cageGroup = new THREE.Group();
            // Mark this as a cage for easy identification
            cageGroup.userData.isCage = true;
            // Store door information
            cageGroup.userData.doorFrames = [];
            
            const frameMaterial = new THREE.MeshBasicMaterial({color: 0x555555});
            const tubeSize = 0.05; // 50mm

            // Create the corner posts
            const posts = [
                [-cageWidth/2, 0, -cageDepth/2], 
                [cageWidth/2, 0, -cageDepth/2], 
                [-cageWidth/2, 0, cageDepth/2], 
                [cageWidth/2, 0, cageDepth/2]
            ];
            
            posts.forEach(pos => {
                const geo = new THREE.BoxGeometry(tubeSize, cageHeight, tubeSize);
                const mesh = new THREE.Mesh(geo, frameMaterial);
                mesh.position.set(pos[0], cageHeight/2, pos[2]);
                cageGroup.add(mesh);
            });

            // Connect horizontal frames - bottom
            connectFrame([-cageWidth/2, 0, -cageDepth/2], [cageWidth/2, 0, -cageDepth/2], cageGroup, tubeSize);
            connectFrame([cageWidth/2, 0, -cageDepth/2], [cageWidth/2, 0, cageDepth/2], cageGroup, tubeSize);
            connectFrame([cageWidth/2, 0, cageDepth/2], [-cageWidth/2, 0, cageDepth/2], cageGroup, tubeSize);
            connectFrame([-cageWidth/2, 0, cageDepth/2], [-cageWidth/2, 0, -cageDepth/2], cageGroup, tubeSize);

            // Connect horizontal frames - top
            connectFrame([-cageWidth/2, cageHeight, -cageDepth/2], [cageWidth/2, cageHeight, -cageDepth/2], cageGroup, tubeSize);
            connectFrame([cageWidth/2, cageHeight, -cageDepth/2], [cageWidth/2, cageHeight, cageDepth/2], cageGroup, tubeSize);
            connectFrame([cageWidth/2, cageHeight, cageDepth/2], [-cageWidth/2, cageHeight, cageDepth/2], cageGroup, tubeSize);
            connectFrame([-cageWidth/2, cageHeight, cageDepth/2], [-cageWidth/2, cageHeight, -cageDepth/2], cageGroup, tubeSize);

            // Create door frames for each floor from floor configurations
            createCageDoorFrames(cageWidth, cageDepth, cageHeight, doorSide, tubeSize, cageGroup);
            
            // Create mesh/grid panels with proper cutouts for door frames
            createCageMeshWithDoorframes(cageWidth, cageDepth, cageHeight, cageGroup);
            
            return cageGroup;
        }

        // Create door frames based on floor configurations
        function createCageDoorFrames(width, depth, height, defaultDoorSide, tubeSize, cageGroup) {
            // Only create door frames if floor configurations exist
            if (floorConfigurations && floorConfigurations.length > 0) {
                // Create door frames for each floor that has doors
                for (let i = 0; i < floorConfigurations.length; i++) {
                    const floorConfig = floorConfigurations[i];
                    const floorY = i * floorConfig.floorHeight;
                    
                    if (floorConfig.doorType !== 'none') {
                        // Only use explicitly defined door sides from floor configuration
                        // No default door side fallback
                        if (floorConfig.doorSides && floorConfig.doorSides.length > 0) {
                            // Create door frame for each door side
                            floorConfig.doorSides.forEach(doorSide => {
                                createSingleDoorFrame(width, depth, floorY, doorSide, tubeSize, cageGroup, floorConfig);
                            });
                        }
                    }
                }
            }
        }

        // Create a single door frame
        function createSingleDoorFrame(width, depth, floorY, side, tubeSize, cageGroup, floorConfig) {
            const frameMaterial = new THREE.MeshBasicMaterial({color: 0xff0000});
            // Use floor configuration door width or default to 900mm
            const doorWidth = floorConfig && floorConfig.doorWidth ? floorConfig.doorWidth * 0.001 : 0.9;
            const doorHeight = 2.1; // 2100mm standard door height
            
            let doorX = 0, doorZ = 0;
            
            // Calculate door position based on side
            if (side === 'front' || side === 'back') {
                doorX = -doorWidth/2;
                doorZ = (side === 'front') ? depth/2 : -depth/2;
            } else {
                doorX = (side === 'left') ? -width/2 : width/2;
                doorZ = -doorWidth/2;
            }
            
            // Create door frame parts
            const verticalGeo = new THREE.BoxGeometry(tubeSize, doorHeight, tubeSize);
            const horizontalGeo = new THREE.BoxGeometry(doorWidth + tubeSize, tubeSize, tubeSize);
            
            const leftPost = new THREE.Mesh(verticalGeo, frameMaterial);
            const rightPost = new THREE.Mesh(verticalGeo, frameMaterial);
            const topBar = new THREE.Mesh(horizontalGeo, frameMaterial);
            
            // Position the door frame based on side
            if (side === 'front' || side === 'back') {
                leftPost.position.set(doorX, floorY + doorHeight/2, doorZ);
                rightPost.position.set(doorX + doorWidth, floorY + doorHeight/2, doorZ);
                topBar.position.set(doorX + doorWidth/2, floorY + doorHeight, doorZ);
            } else {
                leftPost.position.set(doorX, floorY + doorHeight/2, doorZ);
                rightPost.position.set(doorX, floorY + doorHeight/2, doorZ + doorWidth);
                topBar.position.set(doorX, floorY + doorHeight, doorZ + doorWidth/2);
                leftPost.rotation.y = Math.PI/2;
                rightPost.rotation.y = Math.PI/2;
                topBar.rotation.y = Math.PI/2;
            }
            
            // Store door frame information for mesh creation
            cageGroup.userData.doorFrames.push({
                side: side,
                floorY: floorY,
                doorX: doorX,
                doorZ: doorZ,
                doorWidth: doorWidth,
                doorHeight: doorHeight
            });
            
            // Add door frame parts to cage group
            cageGroup.add(leftPost);
            cageGroup.add(rightPost);
            cageGroup.add(topBar);
        }

        // Create mesh with door frame cutouts
        function createCageMeshWithDoorframes(width, depth, height, cageGroup) {
            const wireMaterial = new THREE.LineBasicMaterial({ color: 0x333333 });
            const step = 0.2; // 200mm spacing between grid lines
            
            // Get door frames from the cage group
            const doorFrames = cageGroup.userData.doorFrames || [];
            
            // No fallback door frames - only use explicitly defined ones
            
            ['front', 'back', 'left', 'right', 'top'].forEach(side => {
                const geo = new THREE.BufferGeometry();
                const points = [];
                
                // Filter door frames for this side
                const sideFrames = doorFrames.filter(frame => frame.side === side);
                
                if (side === 'top') {
                    // Top side - full grid
                    for (let x = -width/2; x <= width/2; x += step) {
                        points.push(new THREE.Vector3(x, height, -depth/2));
                        points.push(new THREE.Vector3(x, height, depth/2));
                    }
                    for (let z = -depth/2; z <= depth/2; z += step) {
                        points.push(new THREE.Vector3(-width/2, height, z));
                        points.push(new THREE.Vector3(width/2, height, z));
                    }
                } else if (side === 'front' || side === 'back') {
                    const z = (side === 'front') ? depth/2 : -depth/2;
                    
                    // Horizontal lines
                    for (let y = 0; y <= height; y += step) {
                        let currentLine = []; // Points for current horizontal line
                        let skipLine = false;
                        
                        // Check if this y-level intersects with any door frame
                        for (const frame of sideFrames) {
                            if (y > frame.floorY && y < frame.floorY + frame.doorHeight) {
                                // Split the line at door position
                                points.push(new THREE.Vector3(-width/2, y, z));
                                points.push(new THREE.Vector3(frame.doorX, y, z));
                                
                                points.push(new THREE.Vector3(frame.doorX + frame.doorWidth, y, z));
                                points.push(new THREE.Vector3(width/2, y, z));
                                
                                skipLine = true;
                                break;
                            }
                        }
                        
                        // If no door frames at this height, add full line
                        if (!skipLine) {
                            points.push(new THREE.Vector3(-width/2, y, z));
                            points.push(new THREE.Vector3(width/2, y, z));
                        }
                    }
                    
                    // Vertical lines
                    for (let x = -width/2; x <= width/2; x += step) {
                        let skipLine = false;
                        
                        // Check if this x-position intersects with any door frame
                        for (const frame of sideFrames) {
                            if (x > frame.doorX && x < frame.doorX + frame.doorWidth) {
                                // Split the line at door position
                                points.push(new THREE.Vector3(x, 0, z));
                                points.push(new THREE.Vector3(x, frame.floorY, z));
                                
                                points.push(new THREE.Vector3(x, frame.floorY + frame.doorHeight, z));
                                points.push(new THREE.Vector3(x, height, z));
                                
                                skipLine = true;
                                break;
                            }
                        }
                        
                        // If no door frames at this x-position, add full line
                        if (!skipLine) {
                            points.push(new THREE.Vector3(x, 0, z));
                            points.push(new THREE.Vector3(x, height, z));
                        }
                    }
                } else if (side === 'left' || side === 'right') {
                    const x = (side === 'left') ? -width/2 : width/2;
                    
                    // Horizontal lines
                    for (let y = 0; y <= height; y += step) {
                        let skipLine = false;
                        
                        // Check if this y-level intersects with any door frame
                        for (const frame of sideFrames) {
                            if (y > frame.floorY && y < frame.floorY + frame.doorHeight) {
                                // Split the line at door position
                                points.push(new THREE.Vector3(x, y, -depth/2));
                                points.push(new THREE.Vector3(x, y, frame.doorZ));
                                
                                points.push(new THREE.Vector3(x, y, frame.doorZ + frame.doorWidth));
                                points.push(new THREE.Vector3(x, y, depth/2));
                                
                                skipLine = true;
                                break;
                            }
                        }
                        
                        // If no door frames at this height, add full line
                        if (!skipLine) {
                            points.push(new THREE.Vector3(x, y, -depth/2));
                            points.push(new THREE.Vector3(x, y, depth/2));
                        }
                    }
                    
                    // Vertical lines
                    for (let z = -depth/2; z <= depth/2; z += step) {
                        let skipLine = false;
                        
                        // Check if this z-position intersects with any door frame
                        for (const frame of sideFrames) {
                            if (z > frame.doorZ && z < frame.doorZ + frame.doorWidth) {
                                // Split the line at door position
                                points.push(new THREE.Vector3(x, 0, z));
                                points.push(new THREE.Vector3(x, frame.floorY, z));
                                
                                points.push(new THREE.Vector3(x, frame.floorY + frame.doorHeight, z));
                                points.push(new THREE.Vector3(x, height, z));
                                
                                skipLine = true;
                                break;
                            }
                        }
                        
                        // If no door frames at this z-position, add full line
                        if (!skipLine) {
                            points.push(new THREE.Vector3(x, 0, z));
                            points.push(new THREE.Vector3(x, height, z));
                        }
                    }
                }
                
                // Create the mesh line segments
                if (points.length > 0) {
                    geo.setFromPoints(points);
                    const mesh = new THREE.LineSegments(geo, wireMaterial);
                    cageGroup.add(mesh);
                }
            });
        }

        // Helper function to connect frame posts
        function connectFrame(start, end, cageGroup, tubeSize) {
            const frameMaterial = new THREE.MeshBasicMaterial({color: 0x555555});
            const dx = end[0] - start[0];
            const dy = end[1] - start[1];
            const dz = end[2] - start[2];
            const length = Math.sqrt(dx*dx + dy*dy + dz*dz);

            const geo = new THREE.BoxGeometry(length, tubeSize, tubeSize);
            const mesh = new THREE.Mesh(geo, frameMaterial);
            mesh.position.set((start[0]+end[0])/2, (start[1]+end[1])/2, (start[2]+end[2])/2);
            mesh.rotation.y = Math.atan2(dz, dx);
            cageGroup.add(mesh);
        }

        // Create cage door from cage.html
        function createCageDoor(width, depth, height, side, tubeSize, cageGroup) {
            // REMOVED: This function is deprecated, using createCageDoorFrames instead
            /*
            // Clear any previous door frame data
            cageGroup.userData.doorFrames = [];
            
            // If there are no floor configurations, create just the main door
            if (!floorConfigurations || floorConfigurations.length === 0) {
                createCageDoorFrame(width, depth, 0, side, tubeSize, cageGroup, 0.9, 2.1);
                return;
            }
            
            // Create door frames for each floor that has doors
            for (let i = 0; i < floorConfigurations.length; i++) {
                const floorConfig = floorConfigurations[i];
                // floorY is already in meters, no need for further conversion
                const floorY = i * floorConfig.floorHeight;
                
                if (floorConfig.doorType !== 'none') {
                    // If it's the first floor (i=0) and no door sides specified, use the main door side
                    if (i === 0 && (!floorConfig.doorSides || floorConfig.doorSides.length === 0)) {
                        const doorWidth = floorConfig.doorWidth ? floorConfig.doorWidth * 0.001 : 0.9; // Convert to meters, default to 0.9m
                        createCageDoorFrame(width, depth, floorY, side, tubeSize, cageGroup, doorWidth, 2.1);
                    } else {
                        // For configured door sides
                        floorConfig.doorSides.forEach(doorSide => {
                            // Use the floor door's width for the cage door frame
                            const doorWidth = floorConfig.doorWidth * 0.001; // Convert to meters
                            createCageDoorFrame(width, depth, floorY, doorSide, tubeSize, cageGroup, doorWidth, 2.1);
                        });
                    }
                }
            }
            */
        }

        // Helper function to create a single door frame for the cage
        function createCageDoorFrame(width, depth, floorY, side, tubeSize, cageGroup, doorWidth, doorHeight) {
            // REMOVED: This function is deprecated, using createSingleDoorFrame instead
            /*
            const frameMaterial = new THREE.MeshBasicMaterial({color: 0xff0000});
            let doorX = 0, doorZ = 0;

            if (side === 'front' || side === 'back') {
                doorX = -doorWidth/2;
                doorZ = (side === 'front') ? depth/2 : -depth/2;
            } else {
                doorX = (side === 'left') ? -width/2 : width/2;
                doorZ = -doorWidth/2;
            }

            const verticalGeo = new THREE.BoxGeometry(tubeSize, doorHeight, tubeSize);
            const horizontalGeo = new THREE.BoxGeometry(doorWidth + tubeSize, tubeSize, tubeSize);

            const leftPost = new THREE.Mesh(verticalGeo, frameMaterial);
            const rightPost = new THREE.Mesh(verticalGeo, frameMaterial);
            const topBar = new THREE.Mesh(horizontalGeo, frameMaterial);

            if (side === 'front' || side === 'back') {
                leftPost.position.set(doorX, floorY + doorHeight/2, doorZ);
                rightPost.position.set(doorX + doorWidth, floorY + doorHeight/2, doorZ);
                topBar.position.set(doorX + doorWidth/2, floorY + doorHeight, doorZ);
            } else {
                leftPost.position.set(doorX, floorY + doorHeight/2, doorZ);
                rightPost.position.set(doorX, floorY + doorHeight/2, doorZ + doorWidth);
                topBar.position.set(doorX, floorY + doorHeight, doorZ + doorWidth/2);
                leftPost.rotation.y = Math.PI/2;
                rightPost.rotation.y = Math.PI/2;
                topBar.rotation.y = Math.PI/2;
            }

            // Store the door frame information for mesh creation
            if (!cageGroup.userData.doorFrames) {
                cageGroup.userData.doorFrames = [];
            }
            
            // Store the door frame information with correct coordinates based on side
            cageGroup.userData.doorFrames.push({
                side: side,
                floorY: floorY,
                doorX: doorX,
                doorZ: doorZ,
                doorWidth: doorWidth,
                doorHeight: doorHeight
            });

            cageGroup.add(leftPost);
            cageGroup.add(rightPost);
            cageGroup.add(topBar);
            */
        }

        // Create mesh/grid panels from cage.html
        function createCageMesh(width, depth, height, doorSide, cageGroup) {
            const wireMaterial = new THREE.LineBasicMaterial({ color: 0x333333 });
            const step = 0.2; // 200mm spacing between grid lines
            
            // Get all door frames from the userData
            const doorFrames = cageGroup.userData.doorFrames || [];
            
            // Increase margin to ensure lines don't cross into door frames
            const margin = 0.05; // 50mm margin
            
            // REMOVED: Default door frame creation - only use explicitly defined door frames
            /*
            if (doorFrames.length === 0 && doorSide !== undefined) {
                // Create a default door frame entry for the mesh creation
                doorFrames.push({
                    side: doorSide,
                    floorY: 0,
                    doorX: doorSide === 'front' || doorSide === 'back' ? -0.45 : (doorSide === 'left' ? -width/2 : width/2),
                    doorZ: doorSide === 'left' || doorSide === 'right' ? -0.45 : (doorSide === 'front' ? depth/2 : -depth/2),
                    doorWidth: 0.9,
                    doorHeight: 2.1
                });
            }
            */

            ['front', 'back', 'left', 'right', 'top'].forEach(side => {
                const geo = new THREE.BufferGeometry();
                const points = [];
                
                // Filter door frames for this side
                const sideFrames = doorFrames.filter(frame => frame.side === side);

                if (side === 'top') {
                    for (let x = -width/2; x <= width/2; x += step) {
                        points.push(new THREE.Vector3(x, height, -depth/2));
                        points.push(new THREE.Vector3(x, height, depth/2));
                    }
                    for (let z = -depth/2; z <= depth/2; z += step) {
                        points.push(new THREE.Vector3(-width/2, height, z));
                        points.push(new THREE.Vector3(width/2, height, z));
                    }
                } else if (side === 'front' || side === 'back') {
                    const z = (side === 'front') ? depth/2 : -depth/2;
                    
                    // Vertical lines
                    for (let x = -width/2; x <= width/2; x += step) {
                        let segments = [{start: 0, end: height}]; // Initialize with full height
                        
                        // Process all door frames to cut out segments
                        sideFrames.forEach(frame => {
                            const frameLeft = frame.doorX - margin;
                            const frameRight = frame.doorX + frame.doorWidth + margin;
                            const frameBottom = frame.floorY - margin;
                            const frameTop = frame.floorY + frame.doorHeight + margin;
                            
                            // If x is within door frame width
                            if (x >= frameLeft && x <= frameRight) {
                                // Update segments by removing the door area
                                segments = segments.flatMap(segment => {
                                    // If segment is completely below or above door frame, keep it unchanged
                                    if (segment.end <= frameBottom || segment.start >= frameTop) {
                                        return [segment];
                                    }
                                    
                                    // Otherwise, split the segment
                                    const result = [];
                                    
                                    // Add segment below door if exists
                                    if (segment.start < frameBottom) {
                                        result.push({
                                            start: segment.start,
                                            end: frameBottom
                                        });
                                    }
                                    
                                    // Add segment above door if exists
                                    if (segment.end > frameTop) {
                                        result.push({
                                            start: frameTop,
                                            end: segment.end
                                        });
                                    }
                                    
                                    return result;
                                });
                            }
                        });
                        
                        // Draw all remaining segments
                        segments.forEach(segment => {
                            if (segment.start < segment.end) { // Only draw if segment has height
                                points.push(new THREE.Vector3(x, segment.start, z));
                                points.push(new THREE.Vector3(x, segment.end, z));
                            }
                        });
                    }
                    
                    // Horizontal lines
                    for (let y = 0; y <= height; y += step) {
                        let segments = [{start: -width/2, end: width/2}]; // Initialize with full width
                        
                        // Process all door frames to cut out segments
                        sideFrames.forEach(frame => {
                            const frameLeft = frame.doorX - margin;
                            const frameRight = frame.doorX + frame.doorWidth + margin;
                            const frameBottom = frame.floorY - margin;
                            const frameTop = frame.floorY + frame.doorHeight + margin;
                            
                            // If y is within door frame height
                            if (y > frameBottom && y < frameTop) {
                                // Update segments by removing the door area
                                segments = segments.flatMap(segment => {
                                    // If segment is completely left or right of door frame, keep it unchanged
                                    if (segment.end <= frameLeft || segment.start >= frameRight) {
                                        return [segment];
                                    }
                                    
                                    // Otherwise, split the segment
                                    const result = [];
                                    
                                    // Add segment left of door if exists
                                    if (segment.start < frameLeft) {
                                        result.push({
                                            start: segment.start,
                                            end: frameLeft
                                        });
                                    }
                                    
                                    // Add segment right of door if exists
                                    if (segment.end > frameRight) {
                                        result.push({
                                            start: frameRight,
                                            end: segment.end
                                        });
                                    }
                                    
                                    return result;
                                });
                            }
                        });
                        
                        // Draw all remaining segments
                        segments.forEach(segment => {
                            if (segment.start < segment.end) { // Only draw if segment has width
                                points.push(new THREE.Vector3(segment.start, y, z));
                                points.push(new THREE.Vector3(segment.end, y, z));
                            }
                        });
                    }
                } else if (side === 'left' || side === 'right') {
                    const x = (side === 'left') ? -width/2 : width/2;
                    
                    // Vertical lines
                    for (let z = -depth/2; z <= depth/2; z += step) {
                        let segments = [{start: 0, end: height}]; // Initialize with full height
                        
                        // Process all door frames to cut out segments
                        sideFrames.forEach(frame => {
                            const frameLeft = frame.doorZ - margin;
                            const frameRight = frame.doorZ + frame.doorWidth + margin;
                            const frameBottom = frame.floorY - margin;
                            const frameTop = frame.floorY + frame.doorHeight + margin;
                            
                            // If z is within door frame width
                            if (z >= frameLeft && z <= frameRight) {
                                // Update segments by removing the door area
                                segments = segments.flatMap(segment => {
                                    // If segment is completely below or above door frame, keep it unchanged
                                    if (segment.end <= frameBottom || segment.start >= frameTop) {
                                        return [segment];
                                    }
                                    
                                    // Otherwise, split the segment
                                    const result = [];
                                    
                                    // Add segment below door if exists
                                    if (segment.start < frameBottom) {
                                        result.push({
                                            start: segment.start,
                                            end: frameBottom
                                        });
                                    }
                                    
                                    // Add segment above door if exists
                                    if (segment.end > frameTop) {
                                        result.push({
                                            start: frameTop,
                                            end: segment.end
                                        });
                                    }
                                    
                                    return result;
                                });
                            }
                        });
                        
                        // Draw all remaining segments
                        segments.forEach(segment => {
                            if (segment.start < segment.end) { // Only draw if segment has height
                                points.push(new THREE.Vector3(x, segment.start, z));
                                points.push(new THREE.Vector3(x, segment.end, z));
                            }
                        });
                    }
                    
                    // Horizontal lines
                    for (let y = 0; y <= height; y += step) {
                        let segments = [{start: -depth/2, end: depth/2}]; // Initialize with full depth
                        
                        // Process all door frames to cut out segments
                        sideFrames.forEach(frame => {
                            const frameLeft = frame.doorZ - margin;
                            const frameRight = frame.doorZ + frame.doorWidth + margin;
                            const frameBottom = frame.floorY - margin;
                            const frameTop = frame.floorY + frame.doorHeight + margin;
                            
                            // If y is within door frame height
                            if (y > frameBottom && y < frameTop) {
                                // Update segments by removing the door area
                                segments = segments.flatMap(segment => {
                                    // If segment is completely before or after door frame, keep it unchanged
                                    if (segment.end <= frameLeft || segment.start >= frameRight) {
                                        return [segment];
                                    }
                                    
                                    // Otherwise, split the segment
                                    const result = [];
                                    
                                    // Add segment before door if exists
                                    if (segment.start < frameLeft) {
                                        result.push({
                                            start: segment.start,
                                            end: frameLeft
                                        });
                                    }
                                    
                                    // Add segment after door if exists
                                    if (segment.end > frameRight) {
                                        result.push({
                                            start: frameRight,
                                            end: segment.end
                                        });
                                    }
                                    
                                    return result;
                                });
                            }
                        });
                        
                        // Draw all remaining segments
                        segments.forEach(segment => {
                            if (segment.start < segment.end) { // Only draw if segment has depth
                                points.push(new THREE.Vector3(x, y, segment.start));
                                points.push(new THREE.Vector3(x, y, segment.end));
                            }
                        });
                    }
                }
                
                if (points.length > 0) {
                    geo.setFromPoints(points);
                    const mesh = new THREE.LineSegments(geo, wireMaterial);
                    cageGroup.add(mesh);
                }
            });
        }

        function createCabin() {
            if (elevatorCabin) {
                // Properly dispose of all meshes in the group
                elevatorCabin.traverse(obj => {
                    if (obj.isMesh) {
                        if (obj.geometry) obj.geometry.dispose();
                        if (obj.material) {
                            if (Array.isArray(obj.material)) {
                                obj.material.forEach(material => material.dispose());
                            } else {
                                obj.material.dispose();
                            }
                        }
                    }
                });
                elevatorGroup.remove(elevatorCabin);
            }
            
            const width = parseInt(document.getElementById('elevatorWidth').value) * 0.001 * 0.95;
            const height = parseInt(document.getElementById('elevatorHeight').value) * 0.001;
            const depth = parseInt(document.getElementById('elevatorDepth').value) * 0.001 * 0.95;
            const platformThickness = 0.1;
            
            // Create cabin group
            elevatorCabin = new THREE.Group();
            
            // Create transparent cabin box
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0x3498db,
                transparent: true,
                opacity: 0.3,
                metalness: 0.1,
                roughness: 0.5
            });
            
            const cabinMesh = new THREE.Mesh(geometry, material);
            cabinMesh.position.y = height/2;
            elevatorCabin.add(cabinMesh);
            
            // Position the entire cabin group
            elevatorCabin.position.y = platformThickness + elevatorPosition * 0.001;
            elevatorGroup.add(elevatorCabin);
        }
        
        function createCabinFrame() {
            if (cabinFrame) {
                // Dispose old cabin frame meshes
                cabinFrame.traverse(obj => {
                    if (obj.isMesh) {
                        obj.geometry.dispose();
                        obj.material.dispose();
                    }
                });
                elevatorGroup.remove(cabinFrame);
            }
            
            const width = parseInt(document.getElementById('elevatorWidth').value) * 0.001;
            const height = parseInt(document.getElementById('elevatorHeight').value) * 0.001;
            const depth = parseInt(document.getElementById('elevatorDepth').value) * 0.001;
            const platformThickness = 0.1; // Fixed platform thickness
            
            // Create frame material - steel color
            const frameMaterial = new THREE.MeshStandardMaterial({ 
                color: 0x777777,
                metalness: 0.7,
                roughness: 0.3
            });
            
            // Create frame group
            cabinFrame = new THREE.Group();
            
            // Get frame configuration from UI
            const frameType = document.getElementById('frameType').value;
            const materialType = document.getElementById('materialType').value;
            const materialSize = document.getElementById('materialSize').value;
            
            // Get beam configuration options
            const enableDiagonalSupports = document.getElementById('enableDiagonalSupports').checked;
            const enableMiddleBeams = document.getElementById('enableMiddleBeams').checked;
            const enableCrossBeams = document.getElementById('enableCrossBeams').checked;
            const horizontalGridDivisions = parseInt(document.getElementById('horizontalGridDivisions').value) || 0;
            const verticalGridDivisions = parseInt(document.getElementById('verticalGridDivisions').value) || 0;
            
            // Set material dimensions based on material size selection
            let tubeWidth, tubeHeight, tubeThickness;
            switch(materialSize) {
                case 'small':
                    tubeWidth = tubeHeight = 0.05; // 50mm
                    tubeThickness = 0.003; // 3mm
                    break;
                case 'medium':
                    tubeWidth = tubeHeight = 0.08; // 80mm
                    tubeThickness = 0.004; // 4mm
                    break;
                case 'large':
                    tubeWidth = tubeHeight = 0.1; // 100mm
                    tubeThickness = 0.005; // 5mm
                    break;
                default:
                    tubeWidth = tubeHeight = 0.05;
                    tubeThickness = 0.003;
            }
            
            // Base elevation for frame children (group will handle elevator offset)
            const baseElevation = platformThickness;
            
            // Choose frame type based on selection
            if (frameType === 'aFrame') {
                // Get A-Frame options from UI
                const aFrameOption = document.querySelector('.a-frame-option.selected');
                const aFrameSides = aFrameOption ? aFrameOption.getAttribute('data-sides') : 'leftRight';
                const aFrameGridDivisions = parseInt(document.getElementById('aFrameGridDivisions').value) || 2;
                
                // Create A-frame structure
                createAFrameStructure(
                    width, 
                    height, 
                    depth, 
                    frameMaterial, 
                    baseElevation, 
                    tubeWidth, 
                    tubeHeight, 
                    tubeThickness, 
                    aFrameSides, 
                    aFrameGridDivisions
                );
            } else {
                // Create standard rectangular frame
                
                // Helper to calculate position of vertical posts
                const halfWidth = width / 2;
                const halfDepth = depth / 2;
                
                // Create vertical posts at each corner
                const postGeometry = new THREE.BoxGeometry(tubeWidth, height, tubeWidth);
                
                const frontLeftPost = new THREE.Mesh(postGeometry, frameMaterial.clone());
                frontLeftPost.position.set(-halfWidth + tubeWidth/2, baseElevation + height/2, halfDepth - tubeWidth/2);
                cabinFrame.add(frontLeftPost);
                
                const frontRightPost = new THREE.Mesh(postGeometry, frameMaterial.clone());
                frontRightPost.position.set(halfWidth - tubeWidth/2, baseElevation + height/2, halfDepth - tubeWidth/2);
                cabinFrame.add(frontRightPost);
                
                const backLeftPost = new THREE.Mesh(postGeometry, frameMaterial.clone());
                backLeftPost.position.set(-halfWidth + tubeWidth/2, baseElevation + height/2, -halfDepth + tubeWidth/2);
                cabinFrame.add(backLeftPost);
                
                const backRightPost = new THREE.Mesh(postGeometry, frameMaterial.clone());
                backRightPost.position.set(halfWidth - tubeWidth/2, baseElevation + height/2, -halfDepth + tubeWidth/2);
                cabinFrame.add(backRightPost);
                
                // Horizontal beams at top and bottom
                const horizontalBeams = [
                    // Bottom beams
                    { x1: -halfWidth, z1: halfDepth, x2: halfWidth, z2: halfDepth, y: baseElevation }, // Front
                    { x1: -halfWidth, z1: -halfDepth, x2: halfWidth, z2: -halfDepth, y: baseElevation }, // Back
                    { x1: -halfWidth, z1: -halfDepth, x2: -halfWidth, z2: halfDepth, y: baseElevation }, // Left
                    { x1: halfWidth, z1: -halfDepth, x2: halfWidth, z2: halfDepth, y: baseElevation }, // Right
                    
                    // Top beams
                    { x1: -halfWidth, z1: halfDepth, x2: halfWidth, z2: halfDepth, y: baseElevation + height }, // Front
                    { x1: -halfWidth, z1: -halfDepth, x2: halfWidth, z2: -halfDepth, y: baseElevation + height }, // Back
                    { x1: -halfWidth, z1: -halfDepth, x2: -halfWidth, z2: halfDepth, y: baseElevation + height }, // Left
                    { x1: halfWidth, z1: -halfDepth, x2: halfWidth, z2: halfDepth, y: baseElevation + height } // Right
                ];
                
                horizontalBeams.forEach(beam => {
                    const length = Math.sqrt(
                        Math.pow(beam.x2 - beam.x1, 2) + 
                        Math.pow(beam.z2 - beam.z1, 2)
                    );
                    
                    const beamGeometry = new THREE.BoxGeometry(length, tubeWidth, tubeWidth);
                    const beamMesh = new THREE.Mesh(beamGeometry, frameMaterial.clone());
                    
                    // Position at the midpoint
                    beamMesh.position.set(
                        (beam.x1 + beam.x2) / 2,
                        beam.y + tubeWidth / 2,
                        (beam.z1 + beam.z2) / 2
                    );
                    
                    // Rotate to align with the direction
                    const angle = Math.atan2(beam.z2 - beam.z1, beam.x2 - beam.x1);
                    beamMesh.rotation.y = angle;
                    
                    cabinFrame.add(beamMesh);
                });
                
                // Add mid-height beams if enabled
                if (enableMiddleBeams) {
                    // Get door configuration
                    const frontDoor = document.getElementById('cabinDoorFront').checked;
                    const backDoor = document.getElementById('cabinDoorBack').checked;
                    const leftDoor = document.getElementById('cabinDoorLeft').checked;
                    const rightDoor = document.getElementById('cabinDoorRight').checked;

                    const midHeightBeams = [
                        // Only add front beam if no front door
                        !frontDoor ? { x1: -halfWidth, z1: halfDepth, x2: halfWidth, z2: halfDepth, y: baseElevation + height/2 } : null, // Front
                        // Only add back beam if no back door
                        !backDoor ? { x1: -halfWidth, z1: -halfDepth, x2: halfWidth, z2: -halfDepth, y: baseElevation + height/2 } : null, // Back
                        // Only add left beam if no left door
                        !leftDoor ? { x1: -halfWidth, z1: -halfDepth, x2: -halfWidth, z2: halfDepth, y: baseElevation + height/2 } : null, // Left
                        // Only add right beam if no right door
                        !rightDoor ? { x1: halfWidth, z1: -halfDepth, x2: halfWidth, z2: halfDepth, y: baseElevation + height/2 } : null // Right
                    ].filter(beam => beam !== null);
                    
                    midHeightBeams.forEach(beam => {
                        const length = Math.sqrt(
                            Math.pow(beam.x2 - beam.x1, 2) + 
                            Math.pow(beam.z2 - beam.z1, 2)
                        );
                        
                        const beamGeometry = new THREE.BoxGeometry(length, tubeWidth, tubeWidth);
                        const beamMesh = new THREE.Mesh(beamGeometry, frameMaterial.clone());
                        
                        // Position at the midpoint
                        beamMesh.position.set(
                            (beam.x1 + beam.x2) / 2,
                            beam.y,
                            (beam.z1 + beam.z2) / 2
                        );
                        
                        // Rotate to align with the direction
                        const angle = Math.atan2(beam.z2 - beam.z1, beam.x2 - beam.x1);
                        beamMesh.rotation.y = angle;
                        
                        cabinFrame.add(beamMesh);
                    });
                }
                
                // Add diagonal supports if enabled
                if (enableDiagonalSupports) {
                    // Get door configuration
                    const frontDoor = document.getElementById('cabinDoorFront').checked;
                    const backDoor = document.getElementById('cabinDoorBack').checked;
                    const leftDoor = document.getElementById('cabinDoorLeft').checked;
                    const rightDoor = document.getElementById('cabinDoorRight').checked;

                    const diagonalBeams = [
                        // Front face diagonals (only if no front door)
                        ...(!frontDoor ? [
                            { x1: -halfWidth, z1: halfDepth, y1: baseElevation, x2: halfWidth, z2: halfDepth, y2: baseElevation + height },
                            { x1: halfWidth, z1: halfDepth, y1: baseElevation, x2: -halfWidth, z2: halfDepth, y2: baseElevation + height }
                        ] : []),
                        // Back face diagonals (only if no back door)
                        ...(!backDoor ? [
                            { x1: -halfWidth, z1: -halfDepth, y1: baseElevation, x2: halfWidth, z2: -halfDepth, y2: baseElevation + height },
                            { x1: halfWidth, z1: -halfDepth, y1: baseElevation, x2: -halfWidth, z2: -halfDepth, y2: baseElevation + height }
                        ] : []),
                        // Left face diagonals (only if no left door)
                        ...(!leftDoor ? [
                            { x1: -halfWidth, z1: -halfDepth, y1: baseElevation, x2: -halfWidth, z2: halfDepth, y2: baseElevation + height },
                            { x1: -halfWidth, z1: halfDepth, y1: baseElevation, x2: -halfWidth, z2: -halfDepth, y2: baseElevation + height }
                        ] : []),
                        // Right face diagonals (only if no right door)
                        ...(!rightDoor ? [
                            { x1: halfWidth, z1: -halfDepth, y1: baseElevation, x2: halfWidth, z2: halfDepth, y2: baseElevation + height },
                            { x1: halfWidth, z1: halfDepth, y1: baseElevation, x2: halfWidth, z2: -halfDepth, y2: baseElevation + height }
                        ] : [])
                    ];
                    
                    diagonalBeams.forEach(beam => {
                        // Calculate length of the diagonal beam
                        const length = Math.sqrt(
                            Math.pow(beam.x2 - beam.x1, 2) + 
                            Math.pow(beam.y2 - beam.y1, 2) + 
                            Math.pow(beam.z2 - beam.z1, 2)
                        );
                        
                        // Create a cylinder for the diagonal beam
                        const beamGeometry = new THREE.CylinderGeometry(tubeWidth/2, tubeWidth/2, length, 8);
                        const beamMesh = new THREE.Mesh(beamGeometry, frameMaterial.clone());
                        
                        // Position and orient the beam
                        const midpoint = {
                            x: (beam.x1 + beam.x2) / 2,
                            y: (beam.y1 + beam.y2) / 2,
                            z: (beam.z1 + beam.z2) / 2
                        };
                        
                        beamMesh.position.set(midpoint.x, midpoint.y, midpoint.z);
                        
                        // Orient the beam to point from start to end
                        beamMesh.lookAt(new THREE.Vector3(beam.x2, beam.y2, beam.z2));
                        beamMesh.rotateX(Math.PI / 2); // Adjust for cylinder orientation
                        
                        cabinFrame.add(beamMesh);
                    });
                }
                
                // Add cross beams for grid pattern if enabled
                if (enableCrossBeams && horizontalGridDivisions > 0 && verticalGridDivisions > 0) {
                    // Get door configuration
                    const frontDoor = document.getElementById('cabinDoorFront').checked;
                    const backDoor = document.getElementById('cabinDoorBack').checked;
                    const leftDoor = document.getElementById('cabinDoorLeft').checked;
                    const rightDoor = document.getElementById('cabinDoorRight').checked;

                    // Create horizontal grid on sides without doors
                    const sides = [
                        !frontDoor ? { normal: 'z', dir: 1, name: 'front' } : null,  // Front face
                        !backDoor ? { normal: 'z', dir: -1, name: 'back' } : null,  // Back face
                        !leftDoor ? { normal: 'x', dir: -1, name: 'left' } : null,  // Left face
                        !rightDoor ? { normal: 'x', dir: 1, name: 'right' } : null    // Right face
                    ].filter(side => side !== null);
                    
                    sides.forEach(side => {
                        // Create grid for each vertical division
                        for (let v = 1; v <= verticalGridDivisions; v++) {
                            const yPos = baseElevation + (height * v) / (verticalGridDivisions + 1);
                            
                            let beam;
                            if (side.normal === 'z') {
                                // Front/back face - horizontal beam across x-axis
                                beam = {
                                    x1: -halfWidth,
                                    z1: side.dir * halfDepth,
                                    x2: halfWidth,
                                    z2: side.dir * halfDepth,
                                    y: yPos
                                };
                            } else {
                                // Left/right face - horizontal beam across z-axis
                                beam = {
                                    x1: side.dir * halfWidth,
                                    z1: -halfDepth,
                                    x2: side.dir * halfWidth,
                                    z2: halfDepth,
                                    y: yPos
                                };
                            }
                            
                            const length = Math.sqrt(
                                Math.pow(beam.x2 - beam.x1, 2) + 
                                Math.pow(beam.z2 - beam.z1, 2)
                            );
                            
                            const beamGeometry = new THREE.BoxGeometry(length, tubeWidth/2, tubeWidth/2);
                            const beamMesh = new THREE.Mesh(beamGeometry, frameMaterial.clone());
                            
                            // Position at the midpoint
                            beamMesh.position.set(
                                (beam.x1 + beam.x2) / 2,
                                beam.y,
                                (beam.z1 + beam.z2) / 2
                            );
                            
                            // Rotate to align with the direction
                            const angle = Math.atan2(beam.z2 - beam.z1, beam.x2 - beam.x1);
                            beamMesh.rotation.y = angle;
                            
                            cabinFrame.add(beamMesh);
                        }
                        
                        // Create grid for each horizontal division
                        if (side.normal === 'z') { // Only for front/back faces
                            for (let h = 1; h <= horizontalGridDivisions; h++) {
                                const xPos = -halfWidth + (width * h) / (horizontalGridDivisions + 1);
                                
                                // Create vertical beam
                                for (let segment = 0; segment <= verticalGridDivisions; segment++) {
                                    const y1 = baseElevation + (height * segment) / (verticalGridDivisions + 1);
                                    const y2 = baseElevation + (height * (segment + 1)) / (verticalGridDivisions + 1);
                                    
                                    const beam = {
                                        x1: xPos,
                                        z1: side.dir * halfDepth,
                                        y1: y1,
                                        x2: xPos,
                                        z2: side.dir * halfDepth,
                                        y2: y2
                                    };
                                    
                                    const length = Math.abs(beam.y2 - beam.y1);
                                    
                                    const beamGeometry = new THREE.BoxGeometry(tubeWidth/2, length, tubeWidth/2);
                                    const beamMesh = new THREE.Mesh(beamGeometry, frameMaterial.clone());
                                    
                                    // Position at the midpoint
                                    beamMesh.position.set(
                                        beam.x1,
                                        (beam.y1 + beam.y2) / 2,
                                        beam.z1
                                    );
                                    
                                    cabinFrame.add(beamMesh);
                                }
                            }
                        } else { // For left/right faces
                            for (let h = 1; h <= horizontalGridDivisions; h++) {
                                const zPos = -halfDepth + (depth * h) / (horizontalGridDivisions + 1);
                                
                                // Create vertical beam
                                for (let segment = 0; segment <= verticalGridDivisions; segment++) {
                                    const y1 = baseElevation + (height * segment) / (verticalGridDivisions + 1);
                                    const y2 = baseElevation + (height * (segment + 1)) / (verticalGridDivisions + 1);
                                    
                                    const beam = {
                                        x1: side.dir * halfWidth,
                                        z1: zPos,
                                        y1: y1,
                                        x2: side.dir * halfWidth,
                                        z2: zPos,
                                        y2: y2
                                    };
                                    
                                    const length = Math.abs(beam.y2 - beam.y1);
                                    
                                    const beamGeometry = new THREE.BoxGeometry(tubeWidth/2, length, tubeWidth/2);
                                    const beamMesh = new THREE.Mesh(beamGeometry, frameMaterial.clone());
                                    
                                    // Position at the midpoint
                                    beamMesh.position.set(
                                        beam.x1,
                                        (beam.y1 + beam.y2) / 2,
                                        beam.z1
                                    );
                                    
                                    cabinFrame.add(beamMesh);
                                }
                            }
                        }
                    });
                }
            }
            
            // Position the entire cabin frame
            cabinFrame.position.y = elevatorPosition * 0.001;
            elevatorGroup.add(cabinFrame);
        }
        
        // Function to integrate grid with cabin frame directly
        function integrateGridWithCabinFrame(cabinFrame, width, height, depth, currentSide, frameMaterial) {
            const gridDivisions = document.getElementById('grid-divisions') ? 
                parseInt(document.getElementById('grid-divisions').value) : 5;
            
            // Save the grid configuration for this side
            gridConfigurations[currentSide] = {
                applied: true,
                type: currentGridType,
                divisions: gridDivisions
            };
            
            // Get tube dimensions from the cabin frame
            const tubeWidth = 0.05; // Use the same dimensions as the cabin frame
            const tubeHeight = 0.05;
            const tubeThickness = 0.003;
            
            const halfWidth = width / 2;
            const halfDepth = depth / 2;
            const baseElevation = 0.1; // Platform thickness
            
            // Material for grid beams (slightly different for visual distinction)
            const gridMaterial = frameMaterial.clone();
            gridMaterial.color.setHex(0x999999);
            
            // Track created grid beams to enable clearing them later
            const createdGridBeams = [];
            
            switch(currentSide) {
                case 'front':
                    // Create horizontal grid lines between left and right sides
                    for (let i = 1; i <= gridDivisions; i++) {
                        const yPos = baseElevation + (height * i) / (gridDivisions + 1);
                        
                        const length = width;
                        
                        const beamGeometry = new THREE.BoxGeometry(length, tubeWidth/2, tubeWidth/2);
                        const beamMesh = new THREE.Mesh(beamGeometry, gridMaterial);
                        
                        beamMesh.position.set(0, yPos, halfDepth);
                        
                        // Add userData for tracking
                        beamMesh.userData = {
                            type: 'grid',
                            side: currentSide,
                            gridType: 'horizontal'
                        };
                        
                        cabinFrame.add(beamMesh);
                        createdGridBeams.push(beamMesh);
                        gridBeams.push(beamMesh); // Add to global tracking array
                    }
                    
                    // Create vertical grid lines between top and bottom
                    for (let i = 1; i <= gridDivisions; i++) {
                        const xPos = -halfWidth + (width * i) / (gridDivisions + 1);
                        
                        const length = height;
                        
                        const beamGeometry = new THREE.BoxGeometry(tubeWidth/2, length, tubeWidth/2);
                        const beamMesh = new THREE.Mesh(beamGeometry, gridMaterial);
                        
                        beamMesh.position.set(xPos, baseElevation + height/2, halfDepth);
                        
                        // Add userData for tracking
                        beamMesh.userData = {
                            type: 'grid',
                            side: currentSide,
                            gridType: 'vertical'
                        };
                        
                        cabinFrame.add(beamMesh);
                        createdGridBeams.push(beamMesh);
                        gridBeams.push(beamMesh); // Add to global tracking array
                    }
                    break;
                    
                case 'back':
                    // Create horizontal grid lines between left and right sides
                    for (let i = 1; i <= gridDivisions; i++) {
                        const yPos = baseElevation + (height * i) / (gridDivisions + 1);
                        
                        const length = width;
                        
                        const beamGeometry = new THREE.BoxGeometry(length, tubeWidth/2, tubeWidth/2);
                        const beamMesh = new THREE.Mesh(beamGeometry, gridMaterial);
                        
                        beamMesh.position.set(0, yPos, -halfDepth);
                        
                        // Add userData for tracking
                        beamMesh.userData = {
                            type: 'grid',
                            side: currentSide,
                            gridType: 'horizontal'
                        };
                        
                        cabinFrame.add(beamMesh);
                        createdGridBeams.push(beamMesh);
                        gridBeams.push(beamMesh); // Add to global tracking array
                    }
                    
                    // Create vertical grid lines between top and bottom
                    for (let i = 1; i <= gridDivisions; i++) {
                        const xPos = -halfWidth + (width * i) / (gridDivisions + 1);
                        
                        const length = height;
                        
                        const beamGeometry = new THREE.BoxGeometry(tubeWidth/2, length, tubeWidth/2);
                        const beamMesh = new THREE.Mesh(beamGeometry, gridMaterial);
                        
                        beamMesh.position.set(xPos, baseElevation + height/2, -halfDepth);
                        
                        // Add userData for tracking
                        beamMesh.userData = {
                            type: 'grid',
                            side: currentSide,
                            gridType: 'vertical'
                        };
                        
                        cabinFrame.add(beamMesh);
                        createdGridBeams.push(beamMesh);
                        gridBeams.push(beamMesh); // Add to global tracking array
                    }
                    break;
                    
                case 'left':
                    // Create horizontal grid lines between front and back sides
                    for (let i = 1; i <= gridDivisions; i++) {
                        const yPos = baseElevation + (height * i) / (gridDivisions + 1);
                        
                        const length = depth;
                        
                        const beamGeometry = new THREE.BoxGeometry(tubeWidth/2, tubeWidth/2, length);
                        const beamMesh = new THREE.Mesh(beamGeometry, gridMaterial);
                        
                        beamMesh.position.set(-halfWidth, yPos, 0);
                        
                        // Add userData for tracking
                        beamMesh.userData = {
                            type: 'grid',
                            side: currentSide,
                            gridType: 'horizontal'
                        };
                        
                        cabinFrame.add(beamMesh);
                        createdGridBeams.push(beamMesh);
                        gridBeams.push(beamMesh); // Add to global tracking array
                    }
                    
                    // Create vertical grid lines between top and bottom
                    for (let i = 1; i <= gridDivisions; i++) {
                        const zPos = -halfDepth + (depth * i) / (gridDivisions + 1);
                        
                        const length = height;
                        
                        const beamGeometry = new THREE.BoxGeometry(tubeWidth/2, length, tubeWidth/2);
                        const beamMesh = new THREE.Mesh(beamGeometry, gridMaterial);
                        
                        beamMesh.position.set(-halfWidth, baseElevation + height/2, zPos);
                        
                        // Add userData for tracking
                        beamMesh.userData = {
                            type: 'grid',
                            side: currentSide,
                            gridType: 'vertical'
                        };
                        
                        cabinFrame.add(beamMesh);
                        createdGridBeams.push(beamMesh);
                        gridBeams.push(beamMesh); // Add to global tracking array
                    }
                    break;
                    
                case 'right':
                    // Create horizontal grid lines between front and back sides
                    for (let i = 1; i <= gridDivisions; i++) {
                        const yPos = baseElevation + (height * i) / (gridDivisions + 1);
                        
                        const length = depth;
                        
                        const beamGeometry = new THREE.BoxGeometry(tubeWidth/2, tubeWidth/2, length);
                        const beamMesh = new THREE.Mesh(beamGeometry, gridMaterial);
                        
                        beamMesh.position.set(halfWidth, yPos, 0);
                        
                        // Add userData for tracking
                        beamMesh.userData = {
                            type: 'grid',
                            side: currentSide,
                            gridType: 'horizontal'
                        };
                        
                        cabinFrame.add(beamMesh);
                        createdGridBeams.push(beamMesh);
                        gridBeams.push(beamMesh); // Add to global tracking array
                    }
                    
                    // Create vertical grid lines between top and bottom
                    for (let i = 1; i <= gridDivisions; i++) {
                        const zPos = -halfDepth + (depth * i) / (gridDivisions + 1);
                        
                        const length = height;
                        
                        const beamGeometry = new THREE.BoxGeometry(tubeWidth/2, length, tubeWidth/2);
                        const beamMesh = new THREE.Mesh(beamGeometry, gridMaterial);
                        
                        beamMesh.position.set(halfWidth, baseElevation + height/2, zPos);
                        
                        // Add userData for tracking
                        beamMesh.userData = {
                            type: 'grid',
                            side: currentSide,
                            gridType: 'vertical'
                        };
                        
                        cabinFrame.add(beamMesh);
                        createdGridBeams.push(beamMesh);
                        gridBeams.push(beamMesh); // Add to global tracking array
                    }
                    break;
                    
                case 'top':
                    // Create horizontal grid lines between left and right sides
                    for (let i = 1; i <= gridDivisions; i++) {
                        const zPos = -halfDepth + (depth * i) / (gridDivisions + 1);
                        
                        const length = width;
                        
                        const beamGeometry = new THREE.BoxGeometry(length, tubeWidth/2, tubeWidth/2);
                        const beamMesh = new THREE.Mesh(beamGeometry, gridMaterial);
                        
                        beamMesh.position.set(0, baseElevation + height, zPos);
                        
                        // Add userData for tracking
                        beamMesh.userData = {
                            type: 'grid',
                            side: currentSide,
                            gridType: 'horizontal'
                        };
                        
                        cabinFrame.add(beamMesh);
                        createdGridBeams.push(beamMesh);
                        gridBeams.push(beamMesh); // Add to global tracking array
                    }
                    
                    // Create vertical grid lines between front and back
                    for (let i = 1; i <= gridDivisions; i++) {
                        const xPos = -halfWidth + (width * i) / (gridDivisions + 1);
                        
                        const length = depth;
                        
                        const beamGeometry = new THREE.BoxGeometry(tubeWidth/2, tubeWidth/2, length);
                        const beamMesh = new THREE.Mesh(beamGeometry, gridMaterial);
                        
                        beamMesh.position.set(xPos, baseElevation + height, 0);
                        
                        // Add userData for tracking
                        beamMesh.userData = {
                            type: 'grid',
                            side: currentSide,
                            gridType: 'vertical'
                        };
                        
                        cabinFrame.add(beamMesh);
                        createdGridBeams.push(beamMesh);
                        gridBeams.push(beamMesh); // Add to global tracking array
                    }
                    break;
                    
                case 'bottom':
                    // Create horizontal grid lines between left and right sides
                    for (let i = 1; i <= gridDivisions; i++) {
                        const zPos = -halfDepth + (depth * i) / (gridDivisions + 1);
                        
                        const length = width;
                        
                        const beamGeometry = new THREE.BoxGeometry(length, tubeWidth/2, tubeWidth/2);
                        const beamMesh = new THREE.Mesh(beamGeometry, gridMaterial);
                        
                        beamMesh.position.set(0, baseElevation, zPos);
                        
                        // Add userData for tracking
                        beamMesh.userData = {
                            type: 'grid',
                            side: currentSide,
                            gridType: 'horizontal'
                        };
                        
                        cabinFrame.add(beamMesh);
                        createdGridBeams.push(beamMesh);
                        gridBeams.push(beamMesh); // Add to global tracking array
                    }
                    
                    // Create vertical grid lines between front and back
                    for (let i = 1; i <= gridDivisions; i++) {
                        const xPos = -halfWidth + (width * i) / (gridDivisions + 1);
                        
                        const length = depth;
                        
                        const beamGeometry = new THREE.BoxGeometry(tubeWidth/2, tubeWidth/2, length);
                        const beamMesh = new THREE.Mesh(beamGeometry, gridMaterial);
                        
                        beamMesh.position.set(xPos, baseElevation, 0);
                        
                        // Add userData for tracking
                        beamMesh.userData = {
                            type: 'grid',
                            side: currentSide,
                            gridType: 'vertical'
                        };
                        
                        cabinFrame.add(beamMesh);
                        createdGridBeams.push(beamMesh);
                        gridBeams.push(beamMesh); // Add to global tracking array
                    }
                    break;
            }
            
            // Add side to tracked sides
            gridSides.add(currentSide);
            
            return cabinFrame;
        }
        
        // Create A-Frame structure for the cabin
        function createAFrameStructure(width, height, depth, material, baseElevation, tubeWidth, tubeHeight, tubeThickness, aFrameSides, aFrameGridDivisions) {
            const beamSize = { width: tubeWidth, height: tubeHeight, thickness: tubeThickness };
            
            if (aFrameSides === 'leftRight') {
                // A-Frames on left and right sides
                
                // Define base corners with adjusted y-position
                const corners = {
                    bl: new THREE.Vector3(-width / 2, baseElevation,  depth / 2),  // back left
                    br: new THREE.Vector3( width / 2, baseElevation,  depth / 2),  // back right
                    fr: new THREE.Vector3( width / 2, baseElevation, -depth / 2),  // front right
                    fl: new THREE.Vector3(-width / 2, baseElevation, -depth / 2)   // front left
                };

                // Create top corners
                const topCorners = {};
                for (let key in corners) {
                    topCorners[key] = corners[key].clone();
                    topCorners[key].y = baseElevation + height;
                }

                // Create vertical columns (all four corners)
                for (let key in corners) {
                    const beam = createFrameBeam(corners[key], topCorners[key], material.clone(), beamSize);
                    cabinFrame.add(beam);
                }

                // Create horizontal beams (bottom and top)
                const keys = ['fl', 'fr', 'br', 'bl', 'fl'];
                for (let i = 0; i < 4; i++) {
                    const bottomBeam = createFrameBeam(corners[keys[i]], corners[keys[i + 1]], material.clone(), beamSize);
                    cabinFrame.add(bottomBeam);
                    
                    const topBeam = createFrameBeam(topCorners[keys[i]], topCorners[keys[i + 1]], material.clone(), beamSize);
                    cabinFrame.add(topBeam);
                }

                // Create mid-level horizontal beams - ONLY FOR LEFT AND RIGHT (A-frame sides)
                const midY = baseElevation + height / 2;
                const midCorners = {};
                for (let key in corners) {
                    midCorners[key] = corners[key].clone();
                    midCorners[key].y = midY;
                }
                
                // Only create mid beams for left and right (A-frame sides)
                const leftBeam = createFrameBeam(midCorners['bl'], midCorners['fl'], material.clone(), beamSize);
                cabinFrame.add(leftBeam);
                
                const rightBeam = createFrameBeam(midCorners['br'], midCorners['fr'], material.clone(), beamSize);
                cabinFrame.add(rightBeam);

                // Create A-frames (left and right)
                createAFrame(corners.bl, corners.fl, material, beamSize, height, baseElevation); // Left
                createAFrame(corners.br, corners.fr, material, beamSize, height, baseElevation); // Right

                // Divide bottom frame into squares
                divideFrame(
                    corners.fl,  // bottom left front
                    corners.fr,  // bottom right front
                    corners.bl,  // bottom left back
                    corners.br,  // bottom right back
                    material,
                    beamSize,
                    aFrameGridDivisions
                );

                // Divide top frame into squares
                divideFrame(
                    topCorners.fl,  // top left front
                    topCorners.fr,  // top right front
                    topCorners.bl,  // top left back
                    topCorners.br,  // top right back
                    material,
                    beamSize,
                    aFrameGridDivisions
                );
            } else {
                // A-Frames on front and back sides
                
                // Define base corners with adjusted y-position
                const corners = {
                    bl: new THREE.Vector3(-width / 2, baseElevation,  depth / 2),  // back left
                    br: new THREE.Vector3( width / 2, baseElevation,  depth / 2),  // back right
                    fr: new THREE.Vector3( width / 2, baseElevation, -depth / 2),  // front right
                    fl: new THREE.Vector3(-width / 2, baseElevation, -depth / 2)   // front left
                };

                // Create top corners
                const topCorners = {};
                for (let key in corners) {
                    topCorners[key] = corners[key].clone();
                    topCorners[key].y = baseElevation + height;
                }

                // Create vertical columns (all four corners)
                for (let key in corners) {
                    const beam = createFrameBeam(corners[key], topCorners[key], material.clone(), beamSize);
                    cabinFrame.add(beam);
                }

                // Create horizontal beams (bottom and top)
                const keys = ['fl', 'fr', 'br', 'bl', 'fl'];
                for (let i = 0; i < 4; i++) {
                    const bottomBeam = createFrameBeam(corners[keys[i]], corners[keys[i + 1]], material.clone(), beamSize);
                    cabinFrame.add(bottomBeam);
                    
                    const topBeam = createFrameBeam(topCorners[keys[i]], topCorners[keys[i + 1]], material.clone(), beamSize);
                    cabinFrame.add(topBeam);
                }

                // Create mid-level horizontal beams - ONLY FOR FRONT AND BACK (A-frame sides)
                const midY = baseElevation + height / 2;
                const midCorners = {};
                for (let key in corners) {
                    midCorners[key] = corners[key].clone();
                    midCorners[key].y = midY;
                }
                
                // Only create mid beams for front and back (A-frame sides)
                const frontBeam = createFrameBeam(midCorners['fl'], midCorners['fr'], material.clone(), beamSize);
                cabinFrame.add(frontBeam);
                
                const backBeam = createFrameBeam(midCorners['bl'], midCorners['br'], material.clone(), beamSize);
                cabinFrame.add(backBeam);

                // Create A-frames (front and back)
                createAFrame(corners.fl, corners.fr, material, beamSize, height, baseElevation); // Front
                createAFrame(corners.bl, corners.br, material, beamSize, height, baseElevation); // Back

                // Divide bottom frame into squares
                divideFrame(
                    corners.fl,  // bottom left front
                    corners.fr,  // bottom right front
                    corners.bl,  // bottom left back
                    corners.br,  // bottom right back
                    material,
                    beamSize,
                    aFrameGridDivisions
                );

                // Divide top frame into squares
                divideFrame(
                    topCorners.fl,  // top left front
                    topCorners.fr,  // top right front
                    topCorners.bl,  // top left back
                    topCorners.br,  // top right back
                    material,
                    beamSize,
                    aFrameGridDivisions
                );
            }
        }
        
        // Create A-frame structure
        function createAFrame(leftCorner, rightCorner, material, beamSize, height, baseElevation) {
            const centerTop = new THREE.Vector3(
                (leftCorner.x + rightCorner.x) / 2,
                baseElevation + height,
                (leftCorner.z + rightCorner.z) / 2
            );
            
            // Left side of A
            const leftBeam = createFrameBeam(leftCorner, centerTop, material.clone(), beamSize);
            cabinFrame.add(leftBeam);
            
            // Right side of A
            const rightBeam = createFrameBeam(centerTop, rightCorner, material.clone(), beamSize);
            cabinFrame.add(rightBeam);
            
            // Middle horizontal crossbar
            const leftMid = new THREE.Vector3(
                leftCorner.x + (centerTop.x - leftCorner.x) * 0.5,
                baseElevation + height * 0.5,
                leftCorner.z + (centerTop.z - leftCorner.z) * 0.5
            );
            const rightMid = new THREE.Vector3(
                centerTop.x + (rightCorner.x - centerTop.x) * 0.5,
                baseElevation + height * 0.5,
                centerTop.z + (rightCorner.z - centerTop.z) * 0.5
            );
            
            const crossBeam = createFrameBeam(leftMid, rightMid, material.clone(), beamSize);
            cabinFrame.add(crossBeam);
            
            // Vertical beam from base to middle horizontal bar (50% height)
            const bottomCenter = new THREE.Vector3(
                (leftCorner.x + rightCorner.x) / 2,
                baseElevation,
                (leftCorner.z + rightCorner.z) / 2
            );
            const topOfVertical = new THREE.Vector3(
                bottomCenter.x,
                baseElevation + height * 0.5,
                bottomCenter.z
            );
            
            const verticalBeam = createFrameBeam(bottomCenter, topOfVertical, material.clone(), beamSize);
            cabinFrame.add(verticalBeam);
        }
        
        // Divide frame into grid
        function divideFrame(bottomLeft, bottomRight, topLeft, topRight, material, beamSize, divisions) {
            // Create horizontal beams (along x-axis)
            for (let i = 1; i < divisions; i++) {
                const ratio = i / divisions;
                
                // Bottom edge
                const bottomStart = new THREE.Vector3().lerpVectors(bottomLeft, bottomRight, ratio);
                const bottomEnd = new THREE.Vector3().lerpVectors(topLeft, topRight, ratio);
                const hBeam1 = createFrameBeam(bottomStart, bottomEnd, material.clone(), beamSize);
                cabinFrame.add(hBeam1);
            }
            
            // Create vertical beams (along z-axis)
            for (let i = 1; i < divisions; i++) {
                const ratio = i / divisions;
                
                // Left edge
                const leftStart = new THREE.Vector3().lerpVectors(bottomLeft, topLeft, ratio);
                const leftEnd = new THREE.Vector3().lerpVectors(bottomRight, topRight, ratio);
                const vBeam1 = createFrameBeam(leftStart, leftEnd, material.clone(), beamSize);
                cabinFrame.add(vBeam1);
            }
        }
        
        // Create beam between two points for the cabin frame
        function createFrameBeam(start, end, material, beamSize) {
            // Calculate distance between points
            const direction = new THREE.Vector3().subVectors(end, start);
            const length = direction.length();
            
            // Create the beam geometry
            const beamGeometry = new THREE.BoxGeometry(beamSize.width, length, beamSize.height);
            
            // Create the beam mesh
            const beam = new THREE.Mesh(beamGeometry, material);
            
            // Position the beam at the midpoint between start and end
            const midpoint = new THREE.Vector3().addVectors(start, end).multiplyScalar(0.5);
            beam.position.copy(midpoint);
            
            // Orient the beam to point from start to end
            beam.lookAt(end);
            beam.rotateX(Math.PI / 2);
            
            return beam;
        }
        
        function createBifoldDoor(width, height, panelCount, side) {
            const group = new THREE.Group();
            const material = new THREE.MeshStandardMaterial({
                color: cabinDoorColor,
                transparent: true,
                opacity: cabinDoorOpacity,
                metalness: 0.4,
                roughness: 0.6
            });

            // Track system
            const trackGeometry = new THREE.BoxGeometry(width, 0.02, 0.05);
            const track = new THREE.Mesh(trackGeometry, new THREE.MeshStandardMaterial({ color: 0x333333 }));
            track.position.y = height;
            group.add(track);

            // Calculate panel dimensions
            const panelWidth = width / panelCount;
            const panelGeometry = new THREE.BoxGeometry(panelWidth, height, 0.05);
            
            // Create panels and hinges
            const panels = [];
            for (let i = 0; i < panelCount; i++) {
                const panel = new THREE.Mesh(panelGeometry, material);
                panel.position.x = -width/2 + panelWidth * i + panelWidth/2;
                panel.position.y = height/2;
                
                // Store original position for resetting
                panel.userData.originalX = panel.position.x;
                panel.userData.originalY = panel.position.y;
                panel.userData.originalRotation = 0;
                
                // Determine hinge direction based on door side
                if (side === 'front' || side === 'left') {
                    panel.userData.hingeSide = -1; // Fold to the left
                } else {
                    panel.userData.hingeSide = 1; // Fold to the right
                }
                panel.userData.openProgress = 0;
                
                group.add(panel);
                panels.push(panel);
            }

            // Add door handles to the first and last panels
            const handleGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.1, 8);
            const handleMaterial = new THREE.MeshStandardMaterial({ color: 0x888888 });
            
            // Handle on the right side of the first panel
            const handle1 = new THREE.Mesh(handleGeometry, handleMaterial);
            handle1.position.set(panelWidth/2 - 0.05, 0, 0.03);
            panels[0].add(handle1);
            
            // Handle on the left side of the last panel
            const handle2 = new THREE.Mesh(handleGeometry, handleMaterial);
            handle2.position.set(-panelWidth/2 + 0.05, 0, -0.03);
            panels[panelCount-1].add(handle2);

            group.userData = {
                type: 'bifold',
                panels,
                width,
                height,
                panelCount,
                isOpen: false,
                openProgress: 0,
                side: side
            };

            return group;
        }
        
        function createCollapsibleGate(width, height, panelCount, side) {
            const door = createCollapsibleDoor({
                width: width,
                height: height,
                depth: 0.1,
                color: 0x111111, // Default to black metallic
                frameColor: 0x333333,
                panelCount: panelCount
            });
            door.userData = {
                type: 'collapsible',
                width,
                height,
                panelCount,
                side: side,
                isOpen: false
            };
            return door;
        }
        
        function createRollerShutter(width, height, side) {
            const door = createRollerGate({
                width: width,
                height: height,
                depth: 0.1,
                color: cabinDoorColor,
                frameColor: 0x333333
            });
            door.userData = {
                type: 'roller',
                width,
                height,
                side: side,
                isOpen: false
            };
            return door;
        }
        
        function createSwingDoorWrapper(width, height, side) {
            const doorType = document.getElementById('doorType').value;
            const swingType = doorType === 'swingSingle' ? 'single' : 'double';
            
            const door = createSwingDoor({
                type: swingType,
                width: width,
                height: height
            });
            
            door.userData = {
                type: 'swing',
                width,
                height,
                side: side,
                isOpen: false,
                doorType: swingType
            };
            
            // Return the complete door with toggle functionality
            return door;
        }
        
        function createDoors() {
            // Clear existing doors
            elevatorDoors.forEach(door => elevatorGroup.remove(door));
            elevatorDoors = [];
            
            const doorType = document.getElementById('doorType').value;
            if (doorType === 'none') return;
            
            const width = parseInt(document.getElementById('elevatorWidth').value) * 0.001;
            const height = parseInt(document.getElementById('elevatorHeight').value) * 0.001;
            const depth = parseInt(document.getElementById('elevatorDepth').value) * 0.001;
            const panelCount = parseInt(document.getElementById('doorPanelCount').value);
            const doorWidth = parseInt(document.getElementById('doorWidth').value) * 0.001;
            const leftOffset = parseInt(document.getElementById('leftDoorOffset').value) * 0.001;
            const rightOffset = parseInt(document.getElementById('rightDoorOffset').value) * 0.001;
            const platformThickness = 0.1; // Fixed platform thickness
            
            // Update door color and opacity from UI
            cabinDoorColor = parseInt(document.getElementById('cabinDoorColor').value.replace('#', '0x'));
            cabinDoorOpacity = parseInt(document.getElementById('cabinDoorOpacity').value) / 100;
            document.getElementById('cabinDoorOpacityValue').textContent = parseInt(document.getElementById('cabinDoorOpacity').value) + '%';
            
            // Check which sides should have doors
            const doorSides = [];
            if (document.getElementById('cabinDoorFront').checked) doorSides.push('front');
            if (document.getElementById('cabinDoorBack').checked) doorSides.push('back');
            if (document.getElementById('cabinDoorLeft').checked) doorSides.push('left');
            if (document.getElementById('cabinDoorRight').checked) doorSides.push('right');
            
            // Create doors for each selected side
            doorSides.forEach(side => {
                let doorGroup;
                if (doorType === 'bifold') {
                    doorGroup = createBifoldDoor(doorWidth, height, panelCount, side);
                } else if (doorType === 'collapsible') {
                    doorGroup = createCollapsibleGate(doorWidth, height, panelCount, side);
                } else if (doorType === 'roller') {
                    doorGroup = createRollerShutter(doorWidth, height, side);
                } else if (doorType === 'swingSingle' || doorType === 'swingDouble') {
                    doorGroup = createSwingDoorWrapper(doorWidth, height, side);
                }
                
                // Set door color and opacity
                doorGroup.children.forEach(child => {
                    if (child.material) {
                        child.material.color.setHex(cabinDoorColor);
                        child.material.transparent = true;
                        child.material.opacity = cabinDoorOpacity;
                    }
                });
                
                // Position the door - properly aligned with cabin
                const doorTopPosition = platformThickness + height + elevatorPosition * 0.001;
                const doorOffset = 0.001; // Minimal offset to prevent z-fighting
                
                // Calculate door position based on cabin dimensions and door position
                let doorX = 0, doorZ = 0, rotationY = 0;
                let xOffset = (leftOffset - rightOffset) / 2;
                
                switch(side) {
                    case 'front':
                        doorZ = depth/2 + doorOffset;
                        doorX = xOffset;
                        rotationY = 0;
                        break;
                    case 'back':
                        doorZ = -depth/2 - doorOffset;
                        doorX = xOffset;
                        rotationY = Math.PI;
                        break;
                    case 'left':
                        doorX = -width/2 - doorOffset;
                        doorZ = xOffset;
                        rotationY = Math.PI/2;
                        break;
                    case 'right':
                        doorX = width/2 + doorOffset;
                        doorZ = xOffset;
                        rotationY = -Math.PI/2;
                        break;
                }
                
                // Position the door so its bottom aligns with the cabin top frame
                // For collapsible doors, we need special positioning
                if (doorType === 'collapsible') {
                    // The door is already offset within its group, so we position it at frame center
                    doorGroup.position.set(doorX, doorTopPosition - height/2, doorZ);
                } else {
                    doorGroup.position.set(doorX, doorTopPosition - height, doorZ);
                }
                doorGroup.rotation.y = rotationY;
                
                // Store door metadata
                doorGroup.userData = {
                    type: doorType,
                    side: side,
                    width: doorWidth,
                    height: height,
                    panelCount: panelCount
                };
                
                elevatorDoors.push(doorGroup);
                elevatorGroup.add(doorGroup);
            });
            
            // Update door preview text
            updateDoorPreview();
        }
        
        function createFloorDoor(floorIndex, side, doorType, doorWidth, panelCount, color, opacity) {
            if (!floorDoors[floorIndex]) {
                floorDoors[floorIndex] = [];
            }
            
            const height = parseInt(document.getElementById('elevatorHeight').value) * 0.001;
            const floorY = floorIndex * floorConfigurations[floorIndex].floorHeight;
            const cabinWidth = parseInt(document.getElementById('elevatorWidth').value) * 0.001;
            const cabinDepth = parseInt(document.getElementById('elevatorDepth').value) * 0.001;
            
            let doorGroup;
            if (doorType === 'bifold') {
                doorGroup = createBifoldDoor(doorWidth * 0.001, height, panelCount, side);
            } else if (doorType === 'collapsible') {
                doorGroup = createCollapsibleGate(doorWidth * 0.001, height, panelCount, side);
            } else if (doorType === 'roller') {
                doorGroup = createRollerShutter(doorWidth * 0.001, height, side);
            } else if (doorType === 'swingSingle' || doorType === 'swingDouble') {
                doorGroup = createSwingDoorWrapper(doorWidth * 0.001, height, side);
            }
            
            // Set door color and opacity
            const doorColor = parseInt(color.replace('#', '0x'));
            const doorOpacity = opacity / 100;
            doorGroup.children.forEach(child => {
                if (child.material) {
                    child.material.color.setHex(doorColor);
                    child.material.transparent = true;
                    child.material.opacity = doorOpacity;
                }
            });
            
            // Position the floor door - properly aligned with floor
            const doorOffset = 0.3; // 300mm (1 foot) offset from cabin
            
            let doorX = 0, doorZ = 0, rotationY = 0;
            
            switch(side) {
                case 'front':
                    doorX = 0;
                    doorZ = cabinDepth/2 + doorOffset;
                    rotationY = 0;
                    break;
                case 'back':
                    doorX = 0;
                    doorZ = -cabinDepth/2 - doorOffset;
                    rotationY = Math.PI;
                    break;
                case 'left':
                    doorX = -cabinWidth/2 - doorOffset;
                    doorZ = 0;
                    rotationY = -Math.PI/2;
                    break;
                case 'right':
                    doorX = cabinWidth/2 + doorOffset;
                    doorZ = 0;
                    rotationY = Math.PI/2;
                    break;
            }
            
            // Special positioning for collapsible doors
            if (doorType === 'collapsible') {
                doorGroup.position.set(doorX, floorY + height/2, doorZ);
            } else {
                doorGroup.position.set(doorX, floorY, doorZ);
            }
            doorGroup.rotation.y = rotationY;
            scene.add(doorGroup);
            
            // Add to tracking array
            floorDoors[floorIndex].push(doorGroup);
            
            // Also create a matching door frame in the cage for each floor door
            const width = parseInt(document.getElementById('elevatorWidth').value) * 0.001;
            const depth = parseInt(document.getElementById('elevatorDepth').value) * 0.001;
            const cageOffset = parseInt(document.getElementById('cageOffset').value) * 0.001;
            const cageWidth = width + 2 * cageOffset;
            const cageDepth = depth + 2 * cageOffset;
            
            // Find the cage group in the scene
            let cageGroup = null;
            scene.traverse(function(object) {
                if (object.userData && object.userData.isCage) {
                    cageGroup = object;
                }
            });
            
            // Only create door frame if we found the cage
            if (cageGroup) {
                createCageDoorFrame(cageWidth, cageDepth, floorY, side, 0.05, cageGroup, doorWidth * 0.001, 2.1);
            }
            
            return doorGroup;
        }
        
        function animateBifoldDoor(door, targetOpen) {
            if (doorAnimationId) {
                cancelAnimationFrame(doorAnimationId);
                doorAnimationId = null;
            }
            
            const { panels, width, panelCount, side } = door.userData;
            const panelWidth = width / panelCount;
            const speed = 0.05;
            
            function update() {
                if (targetOpen && door.userData.openProgress < 1) {
                    door.userData.openProgress += speed;
                } else if (!targetOpen && door.userData.openProgress > 0) {
                    door.userData.openProgress -= speed;
                } else {
                    door.userData.isOpen = targetOpen;
                    return;
                }

                // Animate each panel
                panels.forEach((panel, i) => {
                    const foldAmount = door.userData.openProgress * (Math.PI/2);
                    
                    // Reset to original position before applying new transform
                    panel.position.x = panel.userData.originalX;
                    panel.position.y = panel.userData.originalY;
                    panel.rotation.y = panel.userData.originalRotation;
                    
                    // First panel moves linearly
                    if (i === 0) {
                        if (side === 'front' || side === 'left') {
                            panel.position.x = -width/2 + panelWidth/2 - (width/2) * door.userData.openProgress;
                        } else {
                            panel.position.x = width/2 - panelWidth/2 + (width/2) * door.userData.openProgress;
                        }
                    } 
                    // Other panels rotate and follow
                    else {
                        if (side === 'front' || side === 'left') {
                            panel.rotation.y = -foldAmount;
                            panel.position.x = panels[i-1].position.x + (panelWidth * Math.cos(foldAmount));
                        } else {
                            panel.rotation.y = foldAmount;
                            panel.position.x = panels[i-1].position.x - (panelWidth * Math.cos(foldAmount));
                        }
                    }
                });

                doorAnimationId = requestAnimationFrame(update);
            }
            
            update();
        }
        
        function animateCollapsibleGate(door, targetOpen) {
            if (doorAnimationId) {
                cancelAnimationFrame(doorAnimationId);
                doorAnimationId = null;
            }
            
            door.toggle();
            
            function update() {
                if (door.animating) {
                    door.update();
                    doorAnimationId = requestAnimationFrame(update);
                }
            }
            
            update();
        }
        
        function animateRollerShutter(door, targetOpen) {
            if (doorAnimationId) {
                cancelAnimationFrame(doorAnimationId);
                doorAnimationId = null;
            }
            
            door.toggle();
            
            function update() {
                if (door.animating) {
                    door.update();
                    doorAnimationId = requestAnimationFrame(update);
                }
            }
            
            update();
        }
        
        function animateSwingDoor(door, targetOpen) {
            // Use the toggle function from the swing-door.js
            if (targetOpen !== door.isOpen()) {
                door.toggle();
            }
        }
        
        function toggleDoor() {
            if (elevatorDoors.length === 0) return;
            
            // Check if we should only open doors when floor door is present
            const requireFloorDoor = document.getElementById('requireFloorDoor').checked;
            
            // Only toggle doors that should be active at this floor
            elevatorDoors.forEach(door => {
                if (activeCabinDoors.includes(door.userData.side)) {
                    // If requireFloorDoor is true, only open if there's a floor door
                    if (!requireFloorDoor || (floorDoors[currentFloorIndex] && floorDoors[currentFloorIndex].some(d => d.userData.side === door.userData.side))) {
                        if (door.userData.type === 'bifold') {
                            animateBifoldDoor(door, !isCabinDoorOpen);
                        } else if (door.userData.type === 'collapsible') {
                            animateCollapsibleGate(door, !isCabinDoorOpen);
                        } else if (door.userData.type === 'roller') {
                            animateRollerShutter(door, !isCabinDoorOpen);
                        } else if (door.userData.type === 'swingSingle' || door.userData.type === 'swingDouble') {
                            animateSwingDoor(door, !isCabinDoorOpen);
                        }
                    }
                }
            });
            
            // Update the door state after animation is triggered
            isCabinDoorOpen = !isCabinDoorOpen;
        }
        
        function toggleFloorDoor(floorIndex, open) {
            if (!floorDoors[floorIndex] || floorDoors[floorIndex].length === 0) return;
            
            floorDoors[floorIndex].forEach(door => {
                if (door.userData.type === 'bifold') {
                    animateBifoldDoor(door, open);
                } else if (door.userData.type === 'collapsible') {
                    animateCollapsibleGate(door, open);
                } else if (door.userData.type === 'roller') {
                    animateRollerShutter(door, open);
                } else if (door.userData.type === 'swingSingle' || door.userData.type === 'swingDouble') {
                    animateSwingDoor(door, open);
                }
            });
            
            // Determine which cabin doors should be active at this floor
            activeCabinDoors = [];
            if (floorDoors[floorIndex]) {
                floorDoors[floorIndex].forEach(door => {
                    activeCabinDoors.push(door.userData.side);
                });
            }
        }
        
        function updateDoorPreview() {
            const doorType = document.getElementById('doorType').value;
            const panelCount = document.getElementById('doorPanelCount').value;
            
            if (doorType === 'none') {
                document.getElementById('doorPreview').textContent = 'No Door';
            } else {
                const sides = [];
                if (document.getElementById('cabinDoorFront').checked) sides.push('Front');
                if (document.getElementById('cabinDoorBack').checked) sides.push('Back');
                if (document.getElementById('cabinDoorLeft').checked) sides.push('Left');
                if (document.getElementById('cabinDoorRight').checked) sides.push('Right');
                
                let doorTypeName = doorType.charAt(0).toUpperCase() + doorType.slice(1);
                let panelText = doorType === 'roller' ? 'Slats' : 'Panels';
                
                // Handle swing door special cases
                if (doorType === 'swingSingle') {
                    doorTypeName = 'Single Swing Door';
                    panelText = '';
                } else if (doorType === 'swingDouble') {
                    doorTypeName = 'Double Swing Door';
                    panelText = '';
                }
                
                document.getElementById('doorPreview').textContent = 
                    `Door Preview: ${doorTypeName} (${sides.join(', ')})${panelText ? ' - ' + panelCount + ' ' + panelText : ''}`;
            }
        }
        
        function generateFloors() {
            // Clear existing floors
            floors.forEach(floor => scene.remove(floor));
            floors = [];
            
            // Clear existing floor doors
            for (let i = 0; i < floorDoors.length; i++) {
                if (floorDoors[i]) {
                    floorDoors[i].forEach(door => scene.remove(door));
                }
            }
            floorDoors = [];
            
            // Clear existing cage door frames
            for (let i = 0; i < cageDoorFrames.length; i++) {
                if (cageDoorFrames[i]) {
                    cageDoorFrames[i].forEach(frame => scene.remove(frame));
                }
            }
            cageDoorFrames = [];
            
            const width = parseInt(document.getElementById('elevatorWidth').value) * 0.001;
            const depth = parseInt(document.getElementById('elevatorDepth').value) * 0.001;
            const floorCount = parseInt(document.getElementById('floorCount').value);
            const baseFloorHeight = parseInt(document.getElementById('baseFloorHeight').value) * 0.001;
            
            // Initialize floor configurations
            floorConfigurations = Array(floorCount).fill().map((_, i) => ({
                height: i * baseFloorHeight,
                doorType: i === 0 ? 'roller' : 'none', // Ground floor has door by default
                doorSides: ['front'], // Default to front door
                doorWidth: Math.min(1000, width * 1000 * 0.8),
                doorPanelCount: 4,
                floorHeight: baseFloorHeight,
                doorColor: '#CCCCCC',
                doorOpacity: 100
            }));
            
            // Create top level indicator (height limit)
            const topLevelHeight = floorCount * baseFloorHeight;
            const topLevelGeometry = new THREE.BoxGeometry(width * 1.5, 0.1, depth * 1.5);
            const topLevelMaterial = new THREE.MeshStandardMaterial({ 
                color: 0xff0000,
                transparent: true,
                opacity: 0.3,
                metalness: 0.1,
                roughness: 0.7
            });
            topLevelIndicator = new THREE.Mesh(topLevelGeometry, topLevelMaterial);
            topLevelIndicator.position.y = topLevelHeight;
            scene.add(topLevelIndicator);
            
            // Create floors
            for (let i = 0; i < floorCount; i++) {
                const floorY = i * baseFloorHeight;
                
                // Create floor platform
                const floorGeometry = new THREE.BoxGeometry(width * 1.5, 0.1, depth * 1.5);
                const floorMaterial = new THREE.MeshStandardMaterial({ 
                    color: i === 0 ? 0x666666 : 0x999999,
transparent: true,
    opacity: 0.7,  // Default 30% transparent (70% visible)
                    metalness: 0.1,
                    roughness: 0.7
                });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.position.y = floorY;
                scene.add(floor);
                floors.push(floor);
                
                // Create floor door if configured
                if (floorConfigurations[i].doorType !== 'none') {
                    floorConfigurations[i].doorSides.forEach(side => {
                        createFloorDoor(
                            i, 
                            side, 
                            floorConfigurations[i].doorType,
                            floorConfigurations[i].doorWidth,
                            floorConfigurations[i].doorPanelCount,
                            floorConfigurations[i].doorColor,
                            floorConfigurations[i].doorOpacity
                        );
                    });
                }
                
                // Add floor to list
                updateFloorList();
 updateFloorVisibility();
    updateFloorVisibilityButtons();
            }
        }
        
        function updateFloorList() {
            const floorList = document.getElementById('floorList');
            floorList.innerHTML = '';
            
            floorConfigurations.forEach((config, i) => {
                const floorItem = document.createElement('div');
                floorItem.className = 'floor-item';
                floorItem.innerHTML = `
                    <span>Floor ${i} (${(config.height * 1000).toFixed(0)}mm)</span>
                    <button class="config-floor-btn" data-floor="${i}">Config</button>
                `;
                floorList.appendChild(floorItem);
            });
            
            // Add event listeners to config buttons
            document.querySelectorAll('.config-floor-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const floorIndex = parseInt(this.getAttribute('data-floor'));
                    showFloorConfig(floorIndex);
                });
            });
        }
        
        function showFloorConfig(floorIndex) {
            const config = floorConfigurations[floorIndex];
            const configPanel = document.getElementById('floorConfigPanel');
            const configDetails = document.getElementById('floorConfigDetails');
            
            configPanel.style.display = 'block';
            configDetails.innerHTML = `
                <h4>Floor ${floorIndex} Configuration</h4>
                <div class="floor-config">
                    <label for="floorHeight${floorIndex}">Floor Height (mm):</label>
                    <input type="number" id="floorHeight${floorIndex}" min="2000" max="5000" step="100" value="${(config.floorHeight * 1000).toFixed(0)}">
                    
                    <label for="floorDoorType${floorIndex}">Door Type:</label>
                    <select id="floorDoorType${floorIndex}">
                        <option value="none" ${config.doorType === 'none' ? 'selected' : ''}>No Door</option>
                        <option value="bifold" ${config.doorType === 'bifold' ? 'selected' : ''}>Bifold Door</option>
                        <option value="collapsible" ${config.doorType === 'collapsible' ? 'selected' : ''}>Collapsible Door</option>
                        <option value="roller" ${config.doorType === 'roller' ? 'selected' : ''}>Roller Gate</option>
                        <option value="swingSingle" ${config.doorType === 'swingSingle' ? 'selected' : ''}>Swing Door (Single)</option>
                        <option value="swingDouble" ${config.doorType === 'swingDouble' ? 'selected' : ''}>Swing Door (Double)</option>
                    </select>
                    
                    <div class="door-sides-control">
                        <label>Door Sides:</label>
                        <div class="door-side-option">
                            <input type="checkbox" id="floorDoorFront${floorIndex}" ${config.doorSides.includes('front') ? 'checked' : ''}>
                            <label for="floorDoorFront${floorIndex}">Front</label>
                        </div>
                        <div class="door-side-option">
                            <input type="checkbox" id="floorDoorBack${floorIndex}" ${config.doorSides.includes('back') ? 'checked' : ''}>
                            <label for="floorDoorBack${floorIndex}">Back</label>
                        </div>
                        <div class="door-side-option">
                            <input type="checkbox" id="floorDoorLeft${floorIndex}" ${config.doorSides.includes('left') ? 'checked' : ''}>
                            <label for="floorDoorLeft${floorIndex}">Left Side</label>
                        </div>
                        <div class="door-side-option">
                            <input type="checkbox" id="floorDoorRight${floorIndex}" ${config.doorSides.includes('right') ? 'checked' : ''}>
                            <label for="floorDoorRight${floorIndex}">Right Side</label>
                        </div>
                    </div>
                    
                    <label for="floorDoorWidth${floorIndex}">Door Width (mm):</label>
                    <input type="number" id="floorDoorWidth${floorIndex}" min="500" max="2000" step="50" value="${config.doorWidth}">
                    
                    <label for="floorDoorPanelCount${floorIndex}">Panel Count:</label>
                    <select id="floorDoorPanelCount${floorIndex}">
                        <option value="2" ${config.doorPanelCount === 2 ? 'selected' : ''}>2 Panels</option>
                        <option value="4" ${config.doorPanelCount === 4 ? 'selected' : ''}>4 Panels</option>
                        <option value="6" ${config.doorPanelCount === 6 ? 'selected' : ''}>6 Panels</option>
                    </select>
                    
                    <div>
                        <label>Door Color:</label>
                        <input type="color" id="floorDoorColor${floorIndex}" value="${config.doorColor}" class="color-picker">
                        <label>Opacity:</label>
                        <input type="range" id="floorDoorOpacity${floorIndex}" min="0" max="100" value="${config.doorOpacity}" class="opacity-slider">
                        <span id="floorDoorOpacityValue${floorIndex}">${config.doorOpacity}%</span>
                    </div>
                    
                    <button id="saveFloorConfig${floorIndex}" style="margin-top: 10px;">Save Configuration</button>
                    <button id="testFloorDoor${floorIndex}">Test Door</button>
                </div>
            `;
            
            // Add event listeners for opacity slider
            document.getElementById(`floorDoorOpacity${floorIndex}`).addEventListener('input', function(e) {
                document.getElementById(`floorDoorOpacityValue${floorIndex}`).textContent = e.target.value + '%';
            });
            
            // Add event listeners
            document.getElementById(`saveFloorConfig${floorIndex}`).addEventListener('click', function() {
                saveFloorConfig(floorIndex);
            });
            
            document.getElementById(`testFloorDoor${floorIndex}`).addEventListener('click', function() {
                testFloorDoor(floorIndex);
            });
        }
        
        function saveFloorConfig(floorIndex) {
            const newHeight = parseInt(document.getElementById(`floorHeight${floorIndex}`).value) * 0.001;
            
            // Get selected door sides
            const doorSides = [];
            if (document.getElementById(`floorDoorFront${floorIndex}`).checked) doorSides.push('front');
            if (document.getElementById(`floorDoorBack${floorIndex}`).checked) doorSides.push('back');
            if (document.getElementById(`floorDoorLeft${floorIndex}`).checked) doorSides.push('left');
            if (document.getElementById(`floorDoorRight${floorIndex}`).checked) doorSides.push('right');
            
            // Update all floor heights above this one
            const heightDiff = newHeight - floorConfigurations[floorIndex].floorHeight;
            for (let i = floorIndex; i < floorConfigurations.length; i++) {
                floorConfigurations[i].height = i * newHeight;
                floorConfigurations[i].floorHeight = newHeight;
                
                // Update floor position
                if (floors[i]) {
                    floors[i].position.y = floorConfigurations[i].height;
                }
            }
            
            // Update this floor's configuration
            floorConfigurations[floorIndex] = {
                height: floorIndex * newHeight,
                floorHeight: newHeight,
                doorType: document.getElementById(`floorDoorType${floorIndex}`).value,
                doorSides: doorSides,
                doorWidth: parseInt(document.getElementById(`floorDoorWidth${floorIndex}`).value),
                doorPanelCount: parseInt(document.getElementById(`floorDoorPanelCount${floorIndex}`).value),
                doorColor: document.getElementById(`floorDoorColor${floorIndex}`).value,
                doorOpacity: parseInt(document.getElementById(`floorDoorOpacity${floorIndex}`).value)
            };
            
            // Remove existing floor doors
            if (floorDoors[floorIndex]) {
                floorDoors[floorIndex].forEach(door => scene.remove(door));
                floorDoors[floorIndex] = [];
            }
            
            // Remove existing cage door frames
            if (cageDoorFrames[floorIndex]) {
                cageDoorFrames[floorIndex].forEach(frame => scene.remove(frame));
                cageDoorFrames[floorIndex] = [];
            }
            
            // Recreate floor doors if needed
            if (floorConfigurations[floorIndex].doorType !== 'none') {
                floorConfigurations[floorIndex].doorSides.forEach(side => {
                    createFloorDoor(
                        floorIndex, 
                        side, 
                        floorConfigurations[floorIndex].doorType,
                        floorConfigurations[floorIndex].doorWidth,
                        floorConfigurations[floorIndex].doorPanelCount,
                        floorConfigurations[floorIndex].doorColor,
                        floorConfigurations[floorIndex].doorOpacity
                    );
                });
            }
            
            // Update top level indicator
            if (topLevelIndicator) {
                const width = parseInt(document.getElementById('elevatorWidth').value) * 0.001;
                const depth = parseInt(document.getElementById('elevatorDepth').value) * 0.001;
                const floorCount = parseInt(document.getElementById('floorCount').value);
                topLevelIndicator.position.y = floorCount * newHeight;
            }
            
            document.getElementById('floorConfigPanel').style.display = 'none';
            updateFloorList();
            updateMeasurements();
        }
        
        function testFloorDoor(floorIndex) {
            if (!floorDoors[floorIndex] || floorDoors[floorIndex].length === 0) return;
            
            // Check if any door is open
            const anyDoorOpen = floorDoors[floorIndex].some(door => door.userData.isOpen);
            
            floorDoors[floorIndex].forEach(door => {
                if (door.userData.type === 'bifold') {
                    animateBifoldDoor(door, !anyDoorOpen);
                } else if (door.userData.type === 'collapsible') {
                    animateCollapsibleGate(door, !anyDoorOpen);
                } else if (door.userData.type === 'roller') {
                    animateRollerShutter(door, !anyDoorOpen);
                } else if (door.userData.type === 'swingSingle' || door.userData.type === 'swingDouble') {
                    animateSwingDoor(door, !anyDoorOpen);
                }
            });
        }
        
        function updateMeasurements() {
            // Clear existing measurements
            const container = document.getElementById('measurements-container');
            container.innerHTML = '';
            
            if (!showMeasurements) return;
            
            // Update font size based on scale
            measurementFontSize = parseInt(document.getElementById('measurementScale').value);
            
            const width = parseInt(document.getElementById('elevatorWidth').value) * 0.001;
            const depth = parseInt(document.getElementById('elevatorDepth').value) * 0.001;
            const height = parseInt(document.getElementById('elevatorHeight').value) * 0.001;
            const shaftHeight = parseInt(document.getElementById('shaftHeight').value) * 0.001;
            const platformThickness = 0.1; // Fixed platform thickness
            
            // Get 3D positions of key points
            const cabinTop = platformThickness + height + elevatorPosition * 0.001;
            const cabinBottom = platformThickness + elevatorPosition * 0.001;
            
            // Function to create measurement
            const createMeasurement = (start, end, label, offsetX = 0, offsetY = 0, offsetZ = 0, detail = '') => {
                // Convert to screen coordinates
                const startPos = new THREE.Vector3(start.x + offsetX, start.y + offsetY, start.z + offsetZ);
                const endPos = new THREE.Vector3(end.x + offsetX, end.y + offsetY, end.z + offsetZ);
                
                startPos.project(camera);
                endPos.project(camera);
                
                const startX = (startPos.x * 0.5 + 0.5) * renderer.domElement.width;
                const startY = (-(startPos.y * 0.5) + 0.5) * renderer.domElement.height;
                const endX = (endPos.x * 0.5 + 0.5) * renderer.domElement.width;
                const endY = (-(endPos.y * 0.5) + 0.5) * renderer.domElement.height;
                
                // Calculate length and angle
                const length = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
                const angle = Math.atan2(endY - startY, endX - startX);
                
                // Create measurement line
                const line = document.createElement('div');
                line.className = 'measurement-line';
                line.style.left = startX + 'px';
                line.style.top = startY + 'px';
                line.style.width = length + 'px';
                line.style.transformOrigin = '0 0';
                line.style.transform = 'rotate(' + angle + 'rad)';
                line.style.height = '2px';
                container.appendChild(line);
                
                // Create measurement text
                const text = document.createElement('div');
                text.className = 'measurement-text';
                text.textContent = label;
                text.style.fontSize = measurementFontSize + 'px';
                text.style.left = (startX + (endX - startX)/2 - 30) + 'px';
                text.style.top = (startY + (endY - startY)/2 - 15) + 'px';
                container.appendChild(text);
                
                // Create arrows
                const arrow1 = document.createElement('div');
                arrow1.className = 'measurement-arrow';
                arrow1.style.left = (startX - 5) + 'px';
                arrow1.style.top = (startY - 5) + 'px';
                arrow1.style.borderWidth = '0 5px 10px 5px';
                arrow1.style.borderColor = 'transparent transparent rgba(231, 76, 60, 0.7) transparent';
                arrow1.style.transform = 'rotate(' + angle + 'rad)';
                container.appendChild(arrow1);
                
                const arrow2 = document.createElement('div');
                arrow2.className = 'measurement-arrow';
                arrow2.style.left = (endX - 5) + 'px';
                arrow2.style.top = (endY - 5) + 'px';
                arrow2.style.borderWidth = '10px 5px 0 5px';
                arrow2.style.borderColor = 'rgba(231, 76, 60, 0.7) transparent transparent transparent';
                arrow2.style.transform = 'rotate(' + angle + 'rad)';
                container.appendChild(arrow2);
                
                // Add detailed measurement if provided
                if (detail) {
                    const detailText = document.createElement('div');
                    detailText.className = 'measurement-detail';
                    detailText.textContent = detail;
                    detailText.style.fontSize = (measurementFontSize - 2) + 'px';
                    detailText.style.left = (startX + (endX - startX)/2 - 100) + 'px';
                    detailText.style.top = (startY + (endY - startY)/2 + 20) + 'px';
                    container.appendChild(detailText);
                }
            };
            
            // Cabin width measurement (on floor)
            if (currentView === 'top' || currentView === 'iso') {
                const start = new THREE.Vector3(-width/2, platformThickness, 0);
                const end = new THREE.Vector3(width/2, platformThickness, 0);
                createMeasurement(start, end, (width*1000) + ' mm', 0, 0, 0, 'Cabin Interior Width');
            }
            
            // Cabin depth measurement (on floor)
            if (currentView === 'top' || currentView === 'iso') {
                const start = new THREE.Vector3(0, platformThickness, -depth/2);
                const end = new THREE.Vector3(0, platformThickness, depth/2);
                createMeasurement(start, end, (depth*1000) + ' mm', 0, 0, 0, 'Cabin Interior Depth');
            }
            
            // Shaft height measurement (on side)
            if (currentView === 'front' || currentView === 'side' || currentView === 'iso') {
                const start = new THREE.Vector3(0, 0, 0);
                const end = new THREE.Vector3(0, shaftHeight, 0);
                createMeasurement(start, end, (shaftHeight*1000) + ' mm', 0, 0, 0, 'Total Shaft Height');
            }
            
            // Cabin height measurement (on side)
            if (currentView === 'front' || currentView === 'side' || currentView === 'iso') {
                const start = new THREE.Vector3(0, cabinBottom, 0);
                const end = new THREE.Vector3(0, cabinBottom + height, 0);
                createMeasurement(start, end, (height*1000) + ' mm', 0, 0, 0, 'Cabin Interior Height');
            }
            
            // Floor height measurements
            if (floors.length > 1 && (currentView === 'front' || currentView === 'side' || currentView === 'iso')) {
                for (let i = 1; i < floors.length; i++) {
                    const floorHeight = floors[i].position.y;
                    const prevFloorHeight = floors[i-1].position.y;
                    const start = new THREE.Vector3(width/2 + 0.5, prevFloorHeight, 0);
                    const end = new THREE.Vector3(width/2 + 0.5, floorHeight, 0);
                    createMeasurement(start, end, ((floorHeight - prevFloorHeight)*1000) + ' mm', 0, 0, 0, `Floor ${i-1} to ${i} Height`);
                }
            }
        }
        
        function startOperation() {
            if (isOperating) return;
            
            isOperating = true;
            document.getElementById('animateBtn').style.display = 'none';
            document.getElementById('stopBtn').style.display = 'inline-block';
            operationState = 'moving';
            operationProgress = 0;
            currentFloorIndex = 0;
            
            // Reset elevator position baseline
            elevatorPosition = 0;
            document.getElementById('positionValue').textContent = '0';
            document.getElementById('currentFloor').textContent = '0';
            
            // Initialize floor selection
            updateFloorSelectionList();
            
            // Cancel any previous elevator animation loop
            if (operationId) {
                cancelAnimationFrame(operationId);
                operationId = null;
            }

            // Build cabin & frame once before animation
            createCabin();
            createCabinFrame();

            operateElevator();
        }
        
        function stopOperation() {
            isOperating = false;
            document.getElementById('animateBtn').style.display = 'inline-block';
            document.getElementById('stopBtn').style.display = 'none';
            
            if (operationId) {
                cancelAnimationFrame(operationId);
                operationId = null;
            }
            
            // Close all doors when stopping
            if (elevatorDoors.length > 0 && isCabinDoorOpen) {
                toggleDoor();
            }
            
            if (floorDoors[currentFloorIndex] && floorDoors[currentFloorIndex].length > 0 && isFloorDoorOpen) {
                toggleFloorDoor(currentFloorIndex, false);
            }
        }
        
        function operateElevator() {
            if (!isOperating) return;
            
            const speed = parseInt(document.getElementById('animationSpeed').value);
            const floorHeight = floorConfigurations[0].floorHeight * 1000; // Get from first floor config
            const floorCount = parseInt(document.getElementById('floorCount').value);
            
            switch(operationState) {
                case 'moving':
                    // Move to next selected floor
                    const targetFloor = getNextSelectedFloor(currentFloorIndex);
                    const targetPosition = targetFloor * floorHeight;
                    
                    if (Math.abs(elevatorPosition - targetPosition) > 10) {
                        // Still moving
                        const direction = targetPosition > elevatorPosition ? 1 : -1;
                        elevatorPosition += speed * 10 * direction;
                        document.getElementById('positionValue').textContent = Math.round(elevatorPosition);
                        
                        // Update cabin position first
                        const platformThickness = 0.1;
                        
                        // Update cabin position
                        elevatorCabin.position.y = platformThickness + elevatorPosition * 0.001;
                        
                        // Make cabin frame follow cabin position
                        cabinFrame.position.y = elevatorPosition * 0.001;
                        
                        // Update door positions
                        elevatorDoors.forEach(door => {
                            const height = parseInt(document.getElementById('elevatorHeight').value) * 0.001;
                            const platformThickness = 0.1;
                            const cabinY = platformThickness + height + elevatorPosition * 0.001;
                            
                            // Special positioning for collapsible doors
                            if (door.userData.type === 'collapsible') {
                                door.position.y = cabinY - height/2; // Center the door vertically
                            } else {
                                door.position.y = cabinY - height; // Maintain alignment with cabin top
                            }
                        });
                    } else {
                        // Reached floor
                        elevatorPosition = targetPosition;
                        currentFloorIndex = targetFloor;
                        document.getElementById('currentFloor').textContent = currentFloorIndex;
                        
                        // Only proceed with door operations if this floor is selected
                        if (floorSelection[currentFloorIndex]) {
                            operationState = 'openingFloor';
                            operationProgress = 0;
                            isFloorDoorOpen = false;
                        } else {
                            // Skip to next floor if current floor is not selected
                            operationState = 'moving';
                            operationProgress = 0;
                        }
                    }
                    break;
                    
                case 'openingFloor':
                    // First open floor door if exists
                    if (floorDoors[currentFloorIndex] && floorDoors[currentFloorIndex].length > 0) {
                        if (!isFloorDoorOpen) {
                            toggleFloorDoor(currentFloorIndex, true);
                            isFloorDoorOpen = true;
                        }
                        operationProgress += speed;
                        if (operationProgress > 100) {
                            operationState = 'openingCabin';
                            operationProgress = 0;
                            isCabinDoorOpen = false;
                        }
                    } else {
                        operationState = 'openingCabin';
                    }
                    break;
                    
                case 'openingCabin':
                    // Then open cabin door (only the side that matches floor door)
                    if (elevatorDoors.length > 0) {
                        if (!isCabinDoorOpen) {
                            toggleDoor();
                            isCabinDoorOpen = true;
                        }
                        operationProgress += speed;
                        if (operationProgress > 100) {
                            operationState = 'waiting';
                            operationProgress = 0;
                        }
                    } else {
                        operationState = 'waiting';
                    }
                    break;
                    
                case 'waiting':
                    // Wait at floor
                    operationProgress += speed;
                    if (operationProgress > 100) {
                        operationState = 'closingCabin';
                        operationProgress = 0;
                    }
                    break;
                    
                case 'closingCabin':
                    // First close cabin door
                    if (elevatorDoors.length > 0) {
                        if (isCabinDoorOpen) {
                            toggleDoor();
                            isCabinDoorOpen = false;
                        }
                        operationProgress += speed;
                        if (operationProgress > 100) {
                            operationState = 'closingFloor';
                            operationProgress = 0;
                        }
                    } else {
                        operationState = 'closingFloor';
                    }
                    break;
                    
                case 'closingFloor':
                    // Then close floor door if exists
                    if (floorDoors[currentFloorIndex] && floorDoors[currentFloorIndex].length > 0) {
                        if (isFloorDoorOpen) {
                            toggleFloorDoor(currentFloorIndex, false);
                            isFloorDoorOpen = false;
                        }
                        operationProgress += speed;
                        if (operationProgress > 100) {
                            operationState = 'moving';
                            operationProgress = 0;
                        }
                    } else {
                        operationState = 'moving';
                    }
                    break;
            }
            
            updateMeasurements();
            operationId = requestAnimationFrame(operateElevator);
        }
function updateFloorVisibilityButtons() {
    const buttons = {
        all: document.getElementById('floorsAllViews'),
        noTop: document.getElementById('floorsNoTopView'),
        none: document.getElementById('floorsNoViews')
    };
    
    // Reset all
    Object.values(buttons).forEach(btn => btn.classList.remove('active'));
    
    // Activate current
    buttons[floorVisibilityMode].classList.add('active');
}
function updateFloorVisibility() {
    const showInTopView = floorVisibilityMode === 'all';
    const showInOtherViews = floorVisibilityMode !== 'none';
    
    floors.forEach(floor => {
        floor.visible = (currentView === 'top') ? showInTopView : showInOtherViews;
    });
    
    // Always show top indicator
    if (topLevelIndicator) topLevelIndicator.visible = true;
}

        function saveProject() {
            // Gather all project data
            projectData = {
                dimensions: {
                    width: parseInt(document.getElementById('elevatorWidth').value),
                    depth: parseInt(document.getElementById('elevatorDepth').value),
                    height: parseInt(document.getElementById('elevatorHeight').value),
                    shaftHeight: parseInt(document.getElementById('shaftHeight').value)
                },
                structural: {
                    columnType: document.getElementById('columnType').value,
                    columnCount: parseInt(document.getElementById('columnCount').value),
                    columnOffset: parseInt(document.getElementById('columnOffset').value),
                    columnRotations: columnRotations
                },
                cabinFrame: {
                    frameType: document.getElementById('frameType').value,
                    materialType: document.getElementById('materialType').value,
                    materialSize: document.getElementById('materialSize').value,
                    horizontalGridDivisions: parseInt(document.getElementById('horizontalGridDivisions').value) || 0,
                    verticalGridDivisions: parseInt(document.getElementById('verticalGridDivisions').value) || 0,
                    enableDiagonalSupports: document.getElementById('enableDiagonalSupports').checked,
                    enableMiddleBeams: document.getElementById('enableMiddleBeams').checked,
                    enableCrossBeams: document.getElementById('enableCrossBeams').checked,
                    aFrameGridDivisions: parseInt(document.getElementById('aFrameGridDivisions').value) || 4,
                    aFrameSides: document.querySelector('.a-frame-option.selected')?.getAttribute('data-sides') || 'leftRight'
                },
                doors: {
                    doorType: document.getElementById('doorType').value,
                    doorWidth: parseInt(document.getElementById('doorWidth').value),
                    panelCount: parseInt(document.getElementById('doorPanelCount').value),
                    leftOffset: parseInt(document.getElementById('leftDoorOffset').value),
                    rightOffset: parseInt(document.getElementById('rightDoorOffset').value),
                    frontDoor: document.getElementById('cabinDoorFront').checked,
                    backDoor: document.getElementById('cabinDoorBack').checked,
                    leftDoor: document.getElementById('cabinDoorLeft').checked,
                    rightDoor: document.getElementById('cabinDoorRight').checked,
                    doorColor: document.getElementById('cabinDoorColor').value,
                    doorOpacity: parseInt(document.getElementById('cabinDoorOpacity').value)
                },
                floors: {
                    baseHeight: parseInt(document.getElementById('baseFloorHeight').value),
                    floorCount: parseInt(document.getElementById('floorCount').value),
                    configurations: floorConfigurations
                },
transparencySettings: {
    floor: parseInt(document.getElementById('floorTransparency').value),
    indicator: parseInt(document.getElementById('indicatorTransparency').value)
},
                viewSettings: {
                    currentView: currentView,
                    measurementScale: parseInt(document.getElementById('measurementScale').value),
                    showMeasurements: showMeasurements
                },
                operation: {
                    elevatorPosition: elevatorPosition,
                    currentFloorIndex: currentFloorIndex
                }
            };
            
            // Convert to JSON and create download
            const dataStr = JSON.stringify(projectData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = 'elevator_design.json';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);
            
            alert('Project saved successfully');
        }
        
        function loadProject() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            
            input.onchange = e => {
                const file = e.target.files[0];
                const reader = new FileReader();
                
                reader.onload = event => {
                    try {
                        const data = JSON.parse(event.target.result);
                        projectData = data;
                        // Set transparency controls
if (data.transparencySettings) {
    document.getElementById('floorTransparency').value = data.transparencySettings.floor;
    document.getElementById('floorTransparencyValue').textContent = data.transparencySettings.floor;
    document.getElementById('indicatorTransparency').value = data.transparencySettings.indicator;
    document.getElementById('indicatorTransparencyValue').textContent = data.transparencySettings.indicator;
    
    // Apply the loaded values
    floors.forEach(floor => {
        floor.material.opacity = 1 - (data.transparencySettings.floor / 100);
        floor.material.transparent = true;
    });
    if (topLevelIndicator) {
        topLevelIndicator.material.opacity = 1 - (data.transparencySettings.indicator / 100);
        topLevelIndicator.material.transparent = true;
    }
}
                        // Apply loaded settings
                        document.getElementById('elevatorWidth').value = data.dimensions.width;
                        document.getElementById('widthValue').textContent = data.dimensions.width;
                        document.getElementById('elevatorDepth').value = data.dimensions.depth;
                        document.getElementById('depthValue').textContent = data.dimensions.depth;
                        document.getElementById('elevatorHeight').value = data.dimensions.height;
                        document.getElementById('heightValue').textContent = data.dimensions.height;
                        document.getElementById('shaftHeight').value = data.dimensions.shaftHeight;
                        document.getElementById('shaftHeightValue').textContent = data.dimensions.shaftHeight;
                        
                        document.getElementById('columnType').value = data.structural.columnType;
                        document.getElementById('columnCount').value = data.structural.columnCount;
                        document.getElementById('columnOffset').value = data.structural.columnOffset;
                        document.getElementById('columnOffsetValue').textContent = data.structural.columnOffset;
                        
                        columnRotations = data.structural.columnRotations;
                        document.getElementById('unifiedColumnRotation').value = columnRotations[0];
                        document.getElementById('unifiedColumnRotationValue').textContent = columnRotations[0];
                        
                        document.getElementById('doorType').value = data.doors.doorType;
                        document.getElementById('doorWidth').value = data.doors.doorWidth;
                        document.getElementById('doorWidthValue').textContent = data.doors.doorWidth;
                        document.getElementById('doorPanelCount').value = data.doors.panelCount;
                        document.getElementById('leftDoorOffset').value = data.doors.leftOffset;
                        document.getElementById('rightDoorOffset').value = data.doors.rightOffset;
                        document.getElementById('cabinDoorFront').checked = data.doors.frontDoor;
                        document.getElementById('cabinDoorBack').checked = data.doors.backDoor;
                        document.getElementById('cabinDoorLeft').checked = data.doors.leftDoor;
                        document.getElementById('cabinDoorRight').checked = data.doors.rightDoor;
                        document.getElementById('cabinDoorColor').value = data.doors.doorColor;
                        document.getElementById('cabinDoorOpacity').value = data.doors.doorOpacity;
                        document.getElementById('cabinDoorOpacityValue').textContent = data.doors.doorOpacity + '%';
                        
                        document.getElementById('baseFloorHeight').value = data.floors.baseHeight;
                        document.getElementById('floorCount').value = data.floors.floorCount;
                        floorConfigurations = data.floors.configurations;
                        
                        currentView = data.viewSettings.currentView;
                        document.getElementById('measurementScale').value = data.viewSettings.measurementScale;
                        document.getElementById('measurementScaleValue').textContent = data.viewSettings.measurementScale;
                        showMeasurements = data.viewSettings.showMeasurements;
                        document.getElementById('toggleMeasure').textContent = showMeasurements ? 'Measurements: On' : 'Measurements: Off';
                        
                        elevatorPosition = data.operation.elevatorPosition;
                        currentFloorIndex = data.operation.currentFloorIndex;
                        document.getElementById('positionValue').textContent = Math.round(elevatorPosition);
                        document.getElementById('currentFloor').textContent = currentFloorIndex;
                        
                        // Rebuild the elevator with new settings
                        generateFloors();
                        createElevator();
                        updateView();
                        updateMeasurements();
                        
                        alert('Project loaded successfully');
                    } catch (error) {
                        alert('Error loading project: ' + error.message);
                    }
                };
                
                reader.readAsText(file);
            };
            
            input.click();
        }
// Add this new function with your other utility functions
function setupViewListeners() {
    ['top', 'front', 'side', 'iso'].forEach(view => {
        document.getElementById(view + 'View').addEventListener('click', () => {
            currentView = view;
            updateView();
            updateMeasurements();
        });
    });
}
        
        function setupEventListeners() {
            console.log("Setting up event listeners");
            
            // Dimension sliders
            document.getElementById('elevatorWidth').addEventListener('input', function(e) {
                document.getElementById('widthValue').textContent = e.target.value;
                createElevator();
                updateFloorDoorPositions();
            });
            
            document.getElementById('elevatorDepth').addEventListener('input', function(e) {
                document.getElementById('depthValue').textContent = e.target.value;
                createElevator();
                updateFloorDoorPositions();
            });
            
            document.getElementById('elevatorHeight').addEventListener('input', function(e) {
                document.getElementById('heightValue').textContent = e.target.value;
                createElevator();
                updateMeasurements();
            });
            
            document.getElementById('shaftHeight').addEventListener('input', function(e) {
                document.getElementById('shaftHeightValue').textContent = e.target.value;
                createElevator();
                updateMeasurements();
            });
            
            // Column rotation unified control
            document.getElementById('unifiedColumnRotation').addEventListener('input', function(e) {
                const angle = parseInt(e.target.value);
                document.getElementById('unifiedColumnRotationValue').textContent = angle;
                
                // Update all column rotations
                for (let i = 0; i < columnRotations.length; i++) {
                    columnRotations[i] = angle;
                    if (document.getElementById(`columnAngle${i}`)) {
                        document.getElementById(`columnAngle${i}`).value = angle;
                        document.getElementById(`columnAngleValue${i}`).textContent = angle;
                    }
                }
                
                createElevator();
            });
            
            // Column configuration
            document.getElementById('columnOffset').addEventListener('input', function(e) {
                document.getElementById('columnOffsetValue').textContent = e.target.value;
                createElevator();
                updateMeasurements();
            });
            
            // Cage offset configuration
            document.getElementById('cageOffset').addEventListener('input', function(e) {
                document.getElementById('cageOffsetValue').textContent = e.target.value;
                createElevator();
                updateMeasurements();
            });
            
            // Enable/disable cage checkbox
            document.getElementById('enableCage').addEventListener('change', function() {
                createElevator();
                updateMeasurements();
            });
            
            // Column type and count
            document.getElementById('columnType').addEventListener('change', function() {
                createElevator();
                // Update column rotation controls when column type changes
                const columnCount = parseInt(document.getElementById('columnCount').value);
                updateColumnRotationControls(columnCount);
                updateMeasurements();
            });
            
            document.getElementById('columnCount').addEventListener('change', function() {
                createElevator();
                // Update column rotation controls when count changes
                const columnCount = parseInt(this.value);
                updateColumnRotationControls(columnCount);
                updateMeasurements();
            });
            
            document.getElementById('cabinDoorRight').addEventListener('change', function() {
                createElevator();
                updateMeasurements();
            });
            
            document.getElementById('leftDoorOffset').addEventListener('change', function() {
                createElevator();
                updateMeasurements();
            });
            
            document.getElementById('rightDoorOffset').addEventListener('change', function() {
                createElevator();
                updateMeasurements();
            });
            
            // Door color and opacity
            document.getElementById('cabinDoorColor').addEventListener('change', function() {
                createElevator();
            });
            
            document.getElementById('cabinDoorOpacity').addEventListener('input', function(e) {
                document.getElementById('cabinDoorOpacityValue').textContent = e.target.value + '%';
                createElevator();
            });
            
            // Cabin frame structure controls
            document.getElementById('frameType').addEventListener('change', function() {
                const aFrameOptions = document.getElementById('aFrameOptions');
                if (this.value === 'aFrame') {
                    aFrameOptions.style.display = 'block';
                    document.getElementById('framePreview').textContent = 'A-Frame Structure with triangular supports for enhanced stability';
                } else {
                    aFrameOptions.style.display = 'none';
                    document.getElementById('framePreview').textContent = 'Standard Rectangular Frame with vertical posts at each corner and horizontal beams';
                }
                createElevator();
                updateMeasurements();
            });
            
            // A-Frame options
            const aFrameOptions = document.querySelectorAll('.a-frame-option');
            aFrameOptions.forEach(option => {
                option.addEventListener('click', function() {
                    aFrameOptions.forEach(o => o.classList.remove('selected'));
                    this.classList.add('selected');
                    createElevator();
                    updateMeasurements();
                });
            });
            
            // Grid and beam configuration controls
            document.getElementById('horizontalGridDivisions').addEventListener('input', function() {
                createElevator();
                updateMeasurements();
            });
            
            document.getElementById('verticalGridDivisions').addEventListener('input', function() {
                createElevator();
                updateMeasurements();
            });
            
            document.getElementById('enableDiagonalSupports').addEventListener('change', function() {
                createElevator();
                updateMeasurements();
            });
            
            document.getElementById('enableMiddleBeams').addEventListener('change', function() {
                createElevator();
                updateMeasurements();
            });
            
            document.getElementById('enableCrossBeams').addEventListener('change', function() {
                createElevator();
                updateMeasurements();
            });
            
            document.getElementById('aFrameGridDivisions').addEventListener('input', function() {
                createElevator();
                updateMeasurements();
            });
            
            document.getElementById('materialType').addEventListener('change', function() {
                createElevator();
                updateMeasurements();
            });
            
            document.getElementById('materialSize').addEventListener('change', function() {
                createElevator();
                updateMeasurements();
            });
            
            // Toggle door button
            document.getElementById('toggleDoorBtn').addEventListener('click', function() {
                toggleDoor();
            });
            
            // Floor management
            document.getElementById('generateFloorsBtn').addEventListener('click', function() {
                generateFloors();
                updateMeasurements();
            });
            
       
            // Measurement scale
            document.getElementById('measurementScale').addEventListener('input', function(e) {
                document.getElementById('measurementScaleValue').textContent = e.target.value;
                updateMeasurements();
            });
            
            // Toggle buttons
            document.getElementById('toggleMeasure').addEventListener('click', function() {
                showMeasurements = !showMeasurements;
                this.textContent = showMeasurements ? 'Measurements: On' : 'Measurements: Off';
                updateMeasurements();
            });
            
            // Floor transparency slider
            document.getElementById('floorTransparency').addEventListener('input', function(e) {
                const value = parseInt(e.target.value);
                document.getElementById('floorTransparencyValue').textContent = value;
                
                // Apply transparency to floors
                floors.forEach(floor => {
                    floor.material.opacity = 1 - (value / 100);
                    floor.material.transparent = true;
                });
            });
            
            // Floor indicator transparency slider
            document.getElementById('indicatorTransparency').addEventListener('input', function(e) {
                const value = parseInt(e.target.value);
                document.getElementById('indicatorTransparencyValue').textContent = value;
                
                // Apply transparency to top indicator
                if (topLevelIndicator) {
                    topLevelIndicator.material.opacity = 1 - (value / 100);
                    topLevelIndicator.material.transparent = true;
                }
            });
            
            // Floor visibility mode buttons
            document.getElementById('floorsAllViews').addEventListener('click', function() {
                floorVisibilityMode = 'all';
                updateFloorVisibilityButtons();
                updateFloorVisibility();
            });
            
            document.getElementById('floorsNoTopView').addEventListener('click', function() {
                floorVisibilityMode = 'noTop';
                updateFloorVisibilityButtons();
                updateFloorVisibility();
            });
            
            document.getElementById('floorsNoViews').addEventListener('click', function() {
                floorVisibilityMode = 'none';
                updateFloorVisibilityButtons();
                updateFloorVisibility();
            });
            
            // Operation controls
            document.getElementById('animateBtn').addEventListener('click', function() {
                startOperation();
            });
            
            document.getElementById('stopBtn').addEventListener('click', function() {
                stopOperation();
            });
            
            document.getElementById('animationSpeed').addEventListener('input', function(e) {
                // Speed is used in the operation loop
            });
            
            // Action buttons
 document.getElementById('exportBtn').addEventListener('click', function() {
    const exportMenu = document.createElement('div');
    exportMenu.style.position = 'fixed'; // Use fixed position instead of absolute
    exportMenu.style.backgroundColor = '#ffffff';
    exportMenu.style.padding = '15px';
    exportMenu.style.border = '3px solid #2c7be5';
    exportMenu.style.borderRadius = '8px';
    exportMenu.style.zIndex = '1000';
    exportMenu.style.boxShadow = '0 8px 16px rgba(0,0,0,0.4)';
    exportMenu.style.width = '350px';
    exportMenu.style.maxWidth = '90%';
    
    // Add some styling to the buttons with improved contrast
    const buttonStyle = 'margin: 8px 0; padding: 10px; width: 100%; background-color: #2c7be5; ' +
                      'border: none; border-radius: 5px; cursor: pointer; transition: all 0.2s; ' +
                      'color: white; font-weight: bold; font-size: 14px; text-align: left;';
    
    exportMenu.innerHTML = `
        <h4 style="margin-top: 0; color: #2c7be5; text-align: center; font-size: 18px; margin-bottom: 15px; border-bottom: 2px solid #e0e0e0; padding-bottom: 10px;">EXPORT OPTIONS</h4>
        <button id="exportOBJ" style="${buttonStyle}">🔹 Export as OBJ (3D Model)</button>
        <button id="exportPDF" style="${buttonStyle}">🔹 Export as PDF (2D Drawings)</button>
        <button id="exportPNGs" style="${buttonStyle}">🔹 Export Side Elevations (High-Quality PNGs)</button>
        <button id="exportVideo" style="${buttonStyle}">🔹 Export Operation Video</button>
        <button id="exportBoth" style="${buttonStyle}">🔹 Export Both OBJ & PDF</button>
        <div style="text-align: right; margin-top: 15px;">
            <button id="closeExportMenu" style="border: 1px solid #ff4d4d; background: #fff0f0; color: #ff4d4d; padding: 5px 10px; border-radius: 4px; cursor: pointer; font-weight: bold;">CLOSE</button>
        </div>
    `;
    
    document.body.appendChild(exportMenu);
    
    // Center menu in viewport
    exportMenu.style.left = '50%';
    exportMenu.style.top = '50%';
    exportMenu.style.transform = 'translate(-50%, -50%)';
    
    // Add hover effect to buttons
    const buttons = exportMenu.querySelectorAll('button');
    buttons.forEach(button => {
        if (button.id !== 'closeExportMenu') {
            button.addEventListener('mouseover', () => {
                button.style.backgroundColor = '#1a68d4';
                button.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
            });
            button.addEventListener('mouseout', () => {
                button.style.backgroundColor = '#2c7be5';
                button.style.boxShadow = 'none';
            });
        } else {
            // Special hover for close button
            button.addEventListener('mouseover', () => {
                button.style.backgroundColor = '#ffdddd';
            });
            button.addEventListener('mouseout', () => {
                button.style.backgroundColor = '#fff0f0';
            });
        }
    });
    
    document.getElementById('exportOBJ').addEventListener('click', () => {
        document.body.removeChild(exportMenu);
        exportAsOBJ();
    });
    
    document.getElementById('exportPDF').addEventListener('click', () => {
        document.body.removeChild(exportMenu);
        exportAsPDF();
    });
    
    document.getElementById('exportPNGs').addEventListener('click', () => {
        document.body.removeChild(exportMenu);
        exportSideElevationPNGs();
    });
    
    document.getElementById('exportVideo').addEventListener('click', () => {
        document.body.removeChild(exportMenu);
        exportOperationVideo();
    });
    
    document.getElementById('exportBoth').addEventListener('click', () => {
        document.body.removeChild(exportMenu);
        exportAsOBJ();
        setTimeout(exportAsPDF, 1000);
    });
    
    document.getElementById('closeExportMenu').addEventListener('click', () => {
        document.body.removeChild(exportMenu);
    });
    
    const closeMenu = (e) => {
        if (!exportMenu.contains(e.target) && e.target !== this) {
            document.body.removeChild(exportMenu);
            document.removeEventListener('click', closeMenu);
        }
    };
    setTimeout(() => document.addEventListener('click', closeMenu), 100);
});  
         document.getElementById('printBtn').addEventListener('click', async function() {
    const originalView = currentView;
    const originalMeasurements = showMeasurements;
    showMeasurements = false;
    updateMeasurements();
    
    const printWindow = window.open('', '_blank');
    printWindow.document.write(`
        <html>
        <head>
            <title>Elevator Design Print</title>
            <style>
                body { font-family: Arial, sans-serif; margin: 20px; }
                h1 { text-align: center; }
                .print-view { margin-bottom: 30px; page-break-after: always; }
                .print-view img { max-width: 100%; border: 1px solid #ccc; }
                .specs { margin-top: 20px; }
                @page { size: auto; margin: 10mm; }
                @media print {
                    body { margin: 0; padding: 0; }
                    .print-view { page-break-after: always; }
                }
.transparency-controls {
    margin-top: 15px;
    padding-top: 15px;
    border-top: 1px solid #eee;
}

.transparency-controls h3 {
    color: #555;
    font-size: 15px;
    margin-bottom: 10px;
}
            </style>
        </head>
        <body>
            <h1>Elevator Design</h1>
            <div id="print-content"></div>
        </body>
        </html>
    `);
    
    const views = [
        { name: 'Top View', type: 'top' },
        { name: 'Front View', type: 'front' },
        { name: 'Side View', type: 'side' },
        { name: '3D View', type: 'iso' }
    ];
    
    for (const view of views) {
        currentView = view.type;
        updateView();
        
        await new Promise(resolve => setTimeout(resolve, 500));
        
        const canvas = await html2canvas(document.querySelector('#canvas'), {
            scale: 1,
            logging: false,
            useCORS: true
        });
        
        const printContent = printWindow.document.getElementById('print-content');
        const div = printWindow.document.createElement('div');
        div.className = 'print-view';
        div.innerHTML = `
            <h2>${view.name}</h2>
            <img src="${canvas.toDataURL('image/jpeg', 0.9)}" />
        `;
        printContent.appendChild(div);
    }
    
    // Add specifications
    const specsDiv = printWindow.document.createElement('div');
    specsDiv.className = 'specs';
    specsDiv.innerHTML = `
        <h2>Specifications</h2>
        <p><strong>Cabin Width:</strong> ${document.getElementById('elevatorWidth').value} mm</p>
        <p><strong>Cabin Depth:</strong> ${document.getElementById('elevatorDepth').value} mm</p>
        <p><strong>Cabin Height:</strong> ${document.getElementById('elevatorHeight').value} mm</p>
        <p><strong>Shaft Height:</strong> ${document.getElementById('shaftHeight').value} mm</p>
        <p><strong>Floor Count:</strong> ${document.getElementById('floorCount').value}</p>
        <p><strong>Column Type:</strong> ${document.getElementById('columnType').selectedOptions[0].text}</p>
        <p><strong>Door Type:</strong> ${document.getElementById('doorType').selectedOptions[0].text}</p>
    `;
    printWindow.document.getElementById('print-content').appendChild(specsDiv);
    
    // Restore settings
    currentView = originalView;
    showMeasurements = originalMeasurements;
    updateView();
    updateMeasurements();
    
    // Print after images load
    printWindow.document.close();
    setTimeout(() => {
        printWindow.print();
    }, 1000);
});
            
            document.getElementById('saveBtn').addEventListener('click', function() {
                saveProject();
            });
            
            document.getElementById('loadBtn').addEventListener('click', function() {
                loadProject();
            });
            
            document.getElementById('resetBtn').addEventListener('click', function() {
                stopOperation();
                elevatorPosition = 0;
                currentFloorIndex = 0;
                document.getElementById('positionValue').textContent = '0';
                document.getElementById('currentFloor').textContent = '0';
                createElevator();
                updateMeasurements();
                
                camera.position.set(50, 50, 50);
                camera.lookAt(0, 0, 0);
                controls.reset();
            });
            
            // Window resize
            window.addEventListener('resize', function() {
                const canvas = document.getElementById('canvas');
                canvas.width = document.getElementById('viewport').clientWidth;
                canvas.height = document.getElementById('viewport').clientHeight;
                renderer.setSize(camera.width, camera.height);
                
                if (camera instanceof THREE.PerspectiveCamera) {
                    camera.aspect = canvas.width / canvas.height;
                    camera.updateProjectionMatrix();
                }
                
                updateMeasurements();
            });
            
            // Door configuration
            document.getElementById('doorType').addEventListener('change', function() {
                createDoors();
                createCabin();
            });
            
            document.getElementById('doorWidth').addEventListener('input', function(e) {
                document.getElementById('doorWidthValue').textContent = e.target.value;
                createDoors();
                createCabin();
            });
            
            document.getElementById('doorPanelCount').addEventListener('change', function() {
                createDoors();
                createCabin();
            });
            
            document.getElementById('leftDoorOffset').addEventListener('input', function(e) {
                document.getElementById('leftDoorOffsetValue').textContent = e.target.value;
                createDoors();
                createCabin();
            });
            
            document.getElementById('rightDoorOffset').addEventListener('input', function(e) {
                document.getElementById('rightDoorOffsetValue').textContent = e.target.value;
                createDoors();
                createCabin();
            });
            
            // Door side selection
            document.getElementById('cabinDoorFront').addEventListener('change', function() {
                createDoors();
                createCabin();
            });
            
            document.getElementById('cabinDoorBack').addEventListener('change', function() {
                createDoors();
                createCabin();
            });
            
            document.getElementById('cabinDoorLeft').addEventListener('change', function() {
                createDoors();
                createCabin();
            });
            
            document.getElementById('cabinDoorRight').addEventListener('change', function() {
                createDoors();
                createCabin();
            });
            
            // Door appearance
            document.getElementById('cabinDoorColor').addEventListener('change', function() {
                createDoors();
                createCabin();
            });
            
            document.getElementById('cabinDoorOpacity').addEventListener('input', function(e) {
                document.getElementById('cabinDoorOpacityValue').textContent = e.target.value + '%';
                createDoors();
                createCabin();
            });
        }
        
function updateView() {
    // Reset all view buttons
    document.querySelectorAll('.tool-button').forEach(btn => {
        btn.classList.remove('active');
    });
  updateFloorVisibility();
    // Activate current view button
    document.getElementById(currentView + 'View').classList.add('active');
    
    // Get model dimensions in meters
    const width = parseInt(document.getElementById('elevatorWidth').value) * 0.001;
    const depth = parseInt(document.getElementById('elevatorDepth').value) * 0.001;
    const height = parseInt(document.getElementById('elevatorHeight').value) * 0.001;
    const shaftHeight = parseInt(document.getElementById('shaftHeight').value) * 0.001;
    
    // Calculate aspect ratio of the viewport
    const viewport = document.getElementById('viewport');
    const aspect = viewport.clientWidth / viewport.clientHeight;
    
    // Calculate the bounding box of the entire scene
    const size = Math.max(width, depth, shaftHeight) * 1.2;
    const centerY = shaftHeight / 2;
    
    switch(currentView) {
        case 'top':
            if (camera instanceof THREE.PerspectiveCamera) {
                camera = new THREE.OrthographicCamera();
            }
            if (aspect >= 1) {
                camera.left = -size;
                camera.right = size;
                camera.top = size / aspect;
                camera.bottom = -size / aspect;
            } else {
                camera.left = -size * aspect;
                camera.right = size * aspect;
                camera.top = size;
                camera.bottom = -size;
            }
            camera.near = 1;
            camera.far = 10000;
            camera.position.set(0, shaftHeight + height + 2, 0);
            camera.lookAt(0, centerY, 0);
            camera.updateProjectionMatrix();
            controls.enableRotate = false;
            break;
            
        case 'front':
            if (camera instanceof THREE.PerspectiveCamera) {
                camera = new THREE.OrthographicCamera();
            }
            if (aspect >= 1) {
                camera.left = -size;
                camera.right = size;
                camera.top = size / aspect;
                camera.bottom = -size / aspect;
            } else {
                camera.left = -size * aspect;
                camera.right = size * aspect;
                camera.top = size;
                camera.bottom = -size;
            }
            camera.near = 1;
            camera.far = 10000;
            camera.position.set(0, centerY, depth + 2);
            camera.lookAt(0, centerY, 0);
            camera.updateProjectionMatrix();
            controls.enableRotate = false;
            break;
            
        case 'side':
            if (camera instanceof THREE.PerspectiveCamera) {
                camera = new THREE.OrthographicCamera();
            }
            if (aspect >= 1) {
                camera.left = -size;
                camera.right = size;
                camera.top = size / aspect;
                camera.bottom = -size / aspect;
            } else {
                camera.left = -size * aspect;
                camera.right = size * aspect;
                camera.top = size;
                camera.bottom = -size;
            }
            camera.near = 1;
            camera.far = 10000;
            camera.position.set(width + 2, centerY, 0);
            camera.lookAt(0, centerY, 0);
            camera.updateProjectionMatrix();
            controls.enableRotate = false;
            break;
            
   case 'iso':
    if (camera instanceof THREE.OrthographicCamera) {
        camera = new THREE.PerspectiveCamera(60, aspect, 0.1, 10000);
    }
    camera.aspect = aspect;
    camera.updateProjectionMatrix();
    
    // Calculate the ideal camera distance based on model size
    const modelSize = Math.max(width, depth, shaftHeight);
    const distance = modelSize * 2.5; // This gives a comfortable viewing distance
    
    // Set camera position - slightly lowered angle looking slightly upward
    camera.position.set(
        distance * 0.7,      // X position (side view)
        distance * 0.5,      // Y position (height) - lowered angle
        distance * 0.7       // Z position (front/back)
    );
    
    // Look at a point about 1/3 up the shaft for good perspective
    camera.lookAt(0, shaftHeight * 0.3, 0);
    controls.enableRotate = true;
    break;
    }
    
    // Update controls
    controls.object = camera;
    controls.target.set(0, centerY, 0);
    controls.update();
}
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            if (controls) controls.update();
            render();
        }

        // Separate render function
        function render() {
            console.log("Render called");
            if (renderer) renderer.render(scene, camera);
        }

        // Initialize the designer
        init();

        // Roller door implementation
        let shutterPanels = [], isOpen = false, animationFrame;
        const panelCount = 20;
        const panelHeight = 0.5;

        function initRollerDoor() {
            // Shaft Box
            const shaftBox = new THREE.Mesh(
                new THREE.BoxGeometry(6, 1, 1),
                new THREE.MeshStandardMaterial({ color: 0x444444 })
            );
            shaftBox.position.set(0, panelCount * panelHeight + 0.5, 0);
            scene.add(shaftBox);

            // Side Guides
            const guideMaterial = new THREE.MeshStandardMaterial({ color: 0x555555 });
            const guideHeight = panelCount * panelHeight;
            const guideL = new THREE.Mesh(new THREE.BoxGeometry(0.3, guideHeight, 0.3), guideMaterial);
            const guideR = new THREE.Mesh(new THREE.BoxGeometry(0.3, guideHeight, 0.3), guideMaterial);
            guideL.position.set(-3.1, guideHeight / 2, 0);
            guideR.position.set(3.1, guideHeight / 2, 0);
            scene.add(guideL, guideR);

            // Shutter Panels with realistic material and separation
            const textureLoader = new THREE.TextureLoader();
            const shutterTexture = textureLoader.load('https://i.imgur.com/w91T8Rs.jpg');
            const panelMaterial = new THREE.MeshStandardMaterial({ map: shutterTexture });

            for (let i = 0; i < panelCount; i++) {
                const panel = new THREE.Mesh(
                    new THREE.BoxGeometry(6, panelHeight - 0.05, 0.1),
                    panelMaterial
                );
                panel.position.set(0, i * panelHeight + 0.5, 0);
                scene.add(panel);
                shutterPanels.push(panel);
            }
        }

        function toggleRollerDoor() {
            if (animationFrame) cancelAnimationFrame(animationFrame);
            isOpen = !isOpen;
            document.getElementById('doorStatus').textContent = isOpen ? 'Open' : 'Closed';
            animateRollerDoor();
        }

        // Update door dimensions based on cabin size
        function updateDoorDimensions(width, height) {
            const scaleX = width / 6; // Original door width is 6
            const scaleY = height / (panelCount * panelHeight);
            
            shutterPanels.forEach(panel => {
                panel.scale.set(scaleX, 1, 1);
            });
            
            // Update guides
            const guides = scene.children.filter(child => 
                child.geometry instanceof THREE.BoxGeometry && 
                child.geometry.parameters.width === 0.3
            );
            
            guides.forEach(guide => {
                guide.scale.set(1, scaleY, 1);
                guide.position.y = (height / 2);
            });
            
            // Update shaft box
            const shaftBox = scene.children.find(child => 
                child.geometry instanceof THREE.BoxGeometry && 
                child.geometry.parameters.width === 6
            );
            if (shaftBox) {
                shaftBox.scale.set(scaleX, 1, 1);
                shaftBox.position.y = height + 0.5;
            }
        }

        function animateRollerDoor() {
            let speed = 0.1;
            let allDone = true;
            for (let i = 0; i < shutterPanels.length; i++) {
                let panel = shutterPanels[i];
                let targetY = isOpen ? panelCount * panelHeight + 1 : i * panelHeight + 0.5;
                if (Math.abs(panel.position.y - targetY) > 0.02) {
                    panel.position.y += (targetY - panel.position.y) * speed;
                    allDone = false;
                }
            }
            renderer.render(scene, camera);
            if (!allDone) animationFrame = requestAnimationFrame(animateRollerDoor);
        }

        function updateFloorDoorPositions() {
            const cabinWidth = parseInt(document.getElementById('elevatorWidth').value) * 0.001;
            const cabinDepth = parseInt(document.getElementById('elevatorDepth').value) * 0.001;
            const doorOffset = 0.3; // 300mm (1 foot) offset from cabin
            const height = parseInt(document.getElementById('elevatorHeight').value) * 0.001;
            
            // Update positions of all floor doors
            for (let floorIndex in floorDoors) {
                floorDoors[floorIndex].forEach(doorGroup => {
                    const side = doorGroup.userData.side;
                    const doorType = doorGroup.userData.type;
                    let doorX = 0, doorZ = 0, rotationY = 0;
                    const floorY = floorIndex * floorConfigurations[floorIndex].floorHeight;
                    
                    switch(side) {
                        case 'front':
                            doorZ = cabinDepth/2 + doorOffset;
                            doorX = 0;
                            rotationY = 0;
                            break;
                        case 'back':
                            doorZ = -cabinDepth/2 - doorOffset;
                            doorX = 0;
                            rotationY = Math.PI;
                            break;
                        case 'left':
                            doorX = -cabinWidth/2 - doorOffset;
                            doorZ = 0;
                            rotationY = Math.PI/2;
                            break;
                        case 'right':
                            doorX = cabinWidth/2 + doorOffset;
                            doorZ = 0;
                            rotationY = -Math.PI/2;
                            break;
                    }
                    
                    // Special positioning for collapsible doors
                    if (doorType === 'collapsible') {
                        doorGroup.position.set(doorX, floorY + height/2, doorZ);
                    } else {
                        doorGroup.position.set(doorX, floorY, doorZ);
                    }
                    doorGroup.rotation.y = rotationY;
                });
            }
        }
        
        function updateFloorSelectionList() {
            const floorCount = parseInt(document.getElementById('floorCount').value);
            const container = document.getElementById('floorSelectionList');
            container.innerHTML = '';
            
            // Only initialize floorSelection if not set or count changed
            if (floorSelection.length !== floorCount) {
                floorSelection = new Array(floorCount).fill(true); // Initialize all floors as selected
            }

            for (let i = 0; i < floorCount; i++) {
                const div = document.createElement('div');
                div.style.marginBottom = '5px';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.id = `floorSelect${i}`;
                checkbox.checked = floorSelection[i]; // Preserve existing selection
                checkbox.addEventListener('change', function() {
                    floorSelection[i] = this.checked;
                });
                
                const label = document.createElement('label');
                label.htmlFor = `floorSelect${i}`;
                label.textContent = `Floor ${i}`;
                
                div.appendChild(checkbox);
                div.appendChild(label);
                container.appendChild(div);
            }
        }
        
        function getNextSelectedFloor(currentFloor) {
            const floorCount = parseInt(document.getElementById('floorCount').value);
            let nextFloor = (currentFloor + 1) % floorCount;
            
            // Find next selected floor
            while (!floorSelection[nextFloor] && nextFloor !== currentFloor) {
                nextFloor = (nextFloor + 1) % floorCount;
            }
            
            return nextFloor;
        }

        function createGrid() {
            if (!cabinFrame) return;
            
            const ctx = canvas.getContext('2d');
            const { width, height, depth } = cabinFrame.getDimensions();
            const { x, y, z } = cabinFrame.getPosition();
            
            // Clear existing grid
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Set grid style
            ctx.strokeStyle = gridColor;
            ctx.globalAlpha = gridOpacity;
            ctx.lineWidth = 1;
            
            // Create grid lines based on current view
            const currentView = getCurrentView();
            
            switch(currentView) {
                case 'top':
                    // Horizontal lines between left and right sides
                    for (let i = -width/2; i <= width/2; i += gridSpacing) {
                        ctx.beginPath();
                        ctx.moveTo(i, -depth/2);
                        ctx.lineTo(i, depth/2);
                        ctx.stroke();
                    }
                    // Vertical lines between front and back sides
                    for (let i = -depth/2; i <= depth/2; i += gridSpacing) {
                        ctx.beginPath();
                        ctx.moveTo(-width/2, i);
                        ctx.lineTo(width/2, i);
                        ctx.stroke();
                    }
                    break;
                    
                case 'front':
                case 'back':
                    // Horizontal lines between left and right sides
                    for (let i = -width/2; i <= width/2; i += gridSpacing) {
                        ctx.beginPath();
                        ctx.moveTo(i, -height/2);
                        ctx.lineTo(i, height/2);
                        ctx.stroke();
                    }
                    // Vertical lines between top and bottom
                    for (let i = -height/2; i <= height/2; i += gridSpacing) {
                        ctx.beginPath();
                        ctx.moveTo(-width/2, i);
                        ctx.lineTo(width/2, i);
                        ctx.stroke();
                    }
                    break;
                    
                case 'left':
                case 'right':
                    // Horizontal lines between front and back sides
                    for (let i = -depth/2; i <= depth/2; i += gridSpacing) {
                        ctx.beginPath();
                        ctx.moveTo(i, -height/2);
                        ctx.lineTo(i, height/2);
                        ctx.stroke();
                    }
                    // Vertical lines between top and bottom
                    for (let i = -height/2; i <= height/2; i += gridSpacing) {
                        ctx.beginPath();
                        ctx.moveTo(-depth/2, i);
                        ctx.lineTo(depth/2, i);
                        ctx.stroke();
                    }
                    break;
            }
        }

        function updateGrid() {
            if (!cabinFrame) return;
            createGrid();
        }

        // Initialize grid properties
        let gridVisible = true;
        let gridSpacing = 50;
        let gridColor = '#cccccc';
        let gridOpacity = 0.5;

        // Add grid controls to the UI
        const gridControls = document.createElement('div');
        gridControls.className = 'control-group';
        gridControls.innerHTML = `
            <h3>Grid Controls</h3>
            <label>
                Grid Spacing:
                <input type="range" min="10" max="100" value="${gridSpacing}" id="gridSpacing">
                <span class="value-display">${gridSpacing}px</span>
            </label>
            <label>
                Grid Color:
                <input type="color" value="${gridColor}" id="gridColor">
            </label>
            <label>
                Grid Opacity:
                <input type="range" min="0" max="1" step="0.1" value="${gridOpacity}" id="gridOpacity">
                <span class="value-display">${gridOpacity}</span>
            </label>
            <button id="toggleGrid">Toggle Grid</button>
        `;

        document.getElementById('designer-panel').appendChild(gridControls);

        // Add event listeners for grid controls
        document.getElementById('gridSpacing').addEventListener('input', function(e) {
            gridSpacing = parseInt(e.target.value);
            document.querySelector('#gridSpacing + .value-display').textContent = `${gridSpacing}px`;
            updateGrid();
        });

        document.getElementById('gridColor').addEventListener('input', function(e) {
            gridColor = e.target.value;
            updateGrid();
        });

        document.getElementById('gridOpacity').addEventListener('input', function(e) {
            gridOpacity = parseFloat(e.target.value);
            document.querySelector('#gridOpacity + .value-display').textContent = gridOpacity;
            updateGrid();
        });

        document.getElementById('toggleGrid').addEventListener('click', function() {
            gridVisible = !gridVisible;
            if (gridVisible) {
                updateGrid();
            } else {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
        });

        // Update grid when cabin frame changes
        cabinFrame.addEventListener('change', updateGrid);

        // Function to clear grid for a specific side
        function clearGridForSide(side) {
            // Remove this side's grid configuration
            gridConfigurations[side] = {
                applied: false,
                type: 'none',
                divisions: 5
            };
            
            // Remove grid beams for this side
            const gridBeamsToRemove = gridBeams.filter(beam => beam.userData && beam.userData.side === side);
            
            gridBeamsToRemove.forEach(beam => {
                if (cabinFrame.children.includes(beam)) {
                    cabinFrame.remove(beam);
                }
                if (beam.geometry) beam.geometry.dispose();
                if (beam.material) beam.material.dispose();
            });
            
            // Update global gridBeams array to exclude removed beams
            gridBeams = gridBeams.filter(beam => !gridBeamsToRemove.includes(beam));
        }

        // Column configuration
        document.getElementById('columnOffset').addEventListener('input', function(e) {
            document.getElementById('columnOffsetValue').textContent = e.target.value;
            createElevator();
            updateMeasurements();
        });
        
        document.getElementById('columnXPosition').addEventListener('input', function updateXPosition(e) {
            // Directly update the display value - multiple methods to ensure it updates
            const displayValue = e.target.value;
            const valueDisplay = document.getElementById('columnXPositionValue');
            valueDisplay.innerHTML = displayValue;
            valueDisplay.textContent = displayValue;
            console.log("X Position updated to:", displayValue, "mm");
            
            // Update column positions directly without recreating the entire elevator
            updateColumnPositions();
        });
        
        document.getElementById('columnZPosition').addEventListener('input', function updateZPosition(e) {
            // Directly update the display value - multiple methods to ensure it updates
            const displayValue = e.target.value;
            const valueDisplay = document.getElementById('columnZPositionValue');
            valueDisplay.innerHTML = displayValue;
            valueDisplay.textContent = displayValue;
            console.log("Z Position updated to:", displayValue, "mm");
            
            // Update column positions directly without recreating the entire elevator
            updateColumnPositions();
        });
        
        // Cage offset configuration
        
        // Function to update column positions without recreating everything
        function updateColumnPositions() {
            console.log("updateColumnPositions called");
            
            // Get position values
            const width = parseInt(document.getElementById('elevatorWidth').value) * 0.001;
            const depth = parseInt(document.getElementById('elevatorDepth').value) * 0.001;
            const height = parseInt(document.getElementById('shaftHeight').value) * 0.001;
            const columnOffset = parseInt(document.getElementById('columnOffset').value) * 0.001;
            const columnXPosition = parseInt(document.getElementById('columnXPosition').value) * 0.001;
            const columnZPosition = parseInt(document.getElementById('columnZPosition').value) * 0.001;
            const columnCount = parseInt(document.getElementById('columnCount').value);
            const columnType = document.getElementById('columnType').value;
            
            console.log("Column values:", {
                columnXPosition: columnXPosition,
                columnZPosition: columnZPosition,
                columnCount: columnCount,
                columnType: columnType,
                columnsLength: columns.length
            });
            
            // Skip if no columns or columns don't exist yet
            if (columnType === 'none' || columns.length === 0) {
                console.log("No columns to update");
                return;
            }
            
            // Calculate positions
            let positions = [];
            
            if (columnCount === 2 && columnType === 'central') {
                positions = [
                    { x: 0, z: depth/2 + columnOffset },
                    { x: 0, z: -depth/2 - columnOffset }
                ];
            } else {
                const xOffset = width/2 + columnOffset;
                const zOffset = depth/2 + columnOffset;
                
                positions = [
                    { x: -xOffset + columnXPosition, z: zOffset - columnZPosition },   // Front Left
                    { x: xOffset - columnXPosition, z: zOffset - columnZPosition },    // Front Right
                    { x: -xOffset + columnXPosition, z: -zOffset + columnZPosition },  // Back Left
                    { x: xOffset - columnXPosition, z: -zOffset + columnZPosition }    // Back Right
                ];
                
                // Use only first two positions if column count is 2
                if (columnCount === 2 && columnType !== 'central') {
                    positions = positions.slice(0, 2);
                }
            }
            
            console.log("New column positions:", positions);
            
            // Update column positions
            for (let i = 0; i < Math.min(columns.length, positions.length); i++) {
                columns[i].position.x = positions[i].x;
                columns[i].position.z = positions[i].z;
                // Update y position if needed (to ensure columns stay at correct height)
                columns[i].position.y = height/2;
                console.log(`Updated column ${i} to:`, columns[i].position);
            }
            
            // Force the scene to update
            updateMeasurements();
            render();
        }

        // Function to ensure all value displays are properly updated
        function updateAllValueDisplays() {
            // Update column position displays
            const xPosition = document.getElementById('columnXPosition').value;
            document.getElementById('columnXPositionValue').textContent = xPosition;
            
            const zPosition = document.getElementById('columnZPosition').value;
            document.getElementById('columnZPositionValue').textContent = zPosition;
            
            // Initialize the cage checkbox to be unchecked by default
            document.getElementById('enableCage').checked = false;
            
            console.log("Value displays initialized:", {
                xPosition: xPosition,
                zPosition: zPosition,
                enableCage: false
            });
        }

        // Direct column position update functions
        function updateColumnX(value) {
            console.log("updateColumnX called with value:", value);
            // Update the display value
            document.getElementById('columnXPositionValue').textContent = value;
            
            // Update column positions directly
            if (columns.length === 0) return;
            
            const width = parseInt(document.getElementById('elevatorWidth').value) * 0.001;
            const depth = parseInt(document.getElementById('elevatorDepth').value) * 0.001;
            const height = parseInt(document.getElementById('shaftHeight').value) * 0.001;
            const columnOffset = parseInt(document.getElementById('columnOffset').value) * 0.001;
            const columnXPosition = parseInt(value) * 0.001; // Convert to meters
            const columnZPosition = parseInt(document.getElementById('columnZPosition').value) * 0.001;
            
            // Skip if no columns
            if (columns.length === 0) return;
            
            // Update each column's position
            const xOffset = width/2 + columnOffset;
            
            for (let i = 0; i < columns.length; i++) {
                // For front-left and back-left columns (indices 0 and 2)
                if (i === 0 || i === 2) {
                    columns[i].position.x = -xOffset + columnXPosition;
                }
                // For front-right and back-right columns (indices 1 and 3)
                else if (i === 1 || i === 3) {
                    columns[i].position.x = xOffset - columnXPosition;
                }
            }
            
            // Force scene update
            render();
        }

        function updateColumnZ(value) {
            console.log("updateColumnZ called with value:", value);
            // Update the display value
            document.getElementById('columnZPositionValue').textContent = value;
            
            // Update column positions directly
            if (columns.length === 0) return;
            
            const width = parseInt(document.getElementById('elevatorWidth').value) * 0.001;
            const depth = parseInt(document.getElementById('elevatorDepth').value) * 0.001;
            const height = parseInt(document.getElementById('shaftHeight').value) * 0.001;
            const columnOffset = parseInt(document.getElementById('columnOffset').value) * 0.001;
            const columnXPosition = parseInt(document.getElementById('columnXPosition').value) * 0.001;
            const columnZPosition = parseInt(value) * 0.001; // Convert to meters
            
            // Skip if no columns
            if (columns.length === 0) return;
            
            // Update each column's position
            const zOffset = depth/2 + columnOffset;
            
            for (let i = 0; i < columns.length; i++) {
                // For front-left and front-right columns (indices 0 and 1)
                if (i === 0 || i === 1) {
                    columns[i].position.z = zOffset - columnZPosition;
                }
                // For back-left and back-right columns (indices 2 and 3)
                else if (i === 2 || i === 3) {
                    columns[i].position.z = -zOffset + columnZPosition;
                }
            }
            
            // Force scene update
            render();
        }

        // Add an animation function to constantly update the scene
        function animate() {
            requestAnimationFrame(animate);
            if (controls) controls.update();
            render();
        }

        // Function to force update all columns
        function forceUpdateColumns() {
            console.log("Force updating columns");
            const valueX = document.getElementById('columnXPosition').value;
            const valueZ = document.getElementById('columnZPosition').value;
            
            updateColumnX(valueX);
            updateColumnZ(valueZ);
            
            // Make sure display values are also updated
            document.getElementById('columnXPositionValue').textContent = valueX;
            document.getElementById('columnZPositionValue').textContent = valueZ;
            
            // Update column rotation controls
            const columnCount = parseInt(document.getElementById('columnCount').value);
            updateColumnRotationControls(columnCount);
            
            // Update unified rotation display
            const unifiedAngle = document.getElementById('unifiedColumnRotation').value;
            document.getElementById('unifiedColumnRotationValue').textContent = unifiedAngle;
            
            console.log("Updated column positions with values X:", valueX, "Z:", valueZ);
            console.log("Updated column rotations with unified angle:", unifiedAngle);
            
            // Apply the unified rotation to all columns if needed
            for (let i = 0; i < columnRotations.length; i++) {
                // Apply rotation to each column via createElevator
                if (columns[i]) {
                    columns[i].rotation.y = columnRotations[i] * Math.PI / 180;
                }
            }
            
            // Force a full elevator recreation to ensure all changes take effect
            createElevator();
        }
    </script>
</body>
</html>
